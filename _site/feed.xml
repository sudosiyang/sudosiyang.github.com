<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>苏思洋的博客</title>
		<description>推崇以用户为中心的设计理念，专注于用户体验设计，游走在视觉设计与前端开发之间</description>
		<link>http://ssy.me</link>
		<atom:link href="http://ssy.me/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>前端工程化技能树整理</title>
				<description>&lt;p&gt;抽时间整理了下自己的前端工程化技能树。先这么放着吧&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2015-12-01/1.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://naotu.baidu.com/file/5ab40db4b487fe39936e1e2432b7f56e?token=c53bf27c5ffeca14&quot;&gt;在线地址&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Tue, 01 Dec 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/12/01/web_build</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/12/01/web_build</guid>
			</item>

			<item>
				<title>ES6 实现几种 设计模式</title>
				<description>&lt;p&gt;最近将部分项目从ES5转换到了ES6,从新的语法中体会到了很多。无论是可读性还是代码量方面都有很大改善。既然引入了es6，那设计模式的实现方法就需要重新写一遍了。&lt;/p&gt;

&lt;h3 id=&quot;单例模式&quot;&gt;单例模式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
let __instance = (function () {
  let instance;
  return (_instance) =&amp;gt; {
    if (_instance) instance = _instance;
    return instance;
  }
})();

class Singleton {
  constructor() {
    if (__instance()) return __instance();
    // todo init
    __instance(this);
  }
}
console.log(new Singleton() == new Singleton())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
class Car{
  constructor(){
    this.door=4;
  }
  static fatcory(type){
      return new Car[type]();
  }
}
Car.Trunk = class Trunk extends Car{
    constructor(){
      super();
      this.door=2
    }
}

console.log(Car.fatcory(&quot;Trunk&quot;).door)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;代理模式&quot;&gt;代理模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用代理模式创建代理对象，让代理对象控制目标对象的访问(目标对象可以是远程的对象、创建开销大的对象或需要安全控制的对象),并且可以在不改变目标对象的情况下添加一些额外的功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
class Real {
  toDo() {
    console.log(`to do something...`);
  }
}

class Proxy extends Real {
  constructor() {
    super();
  }

  toDo() {
    setTimeout(super.toDo, 1000 * N);
  }
}

new Proxy().toDo(); //N s后, to do...

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;迭代模式&quot;&gt;迭代模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
let array = {
  data: [1, 2, 3, 4, 5],
  [Symbol.iterator](){
    let index = 0;
    return {
      next: () =&amp;gt; {
        if (index &amp;lt; this.data.length) return {value: this.data[index++], done: false};
        return {value: undefined, done: true};
      },
      hasNext: () =&amp;gt; index &amp;lt; this.data.length,
      rewind: () =&amp;gt; index = 0,
      current: () =&amp;gt; {
        index -= 1;
        if (index &amp;lt; this.data.length) return {value: this.data[index++], done: false};
        return {value: undefined, done: true};
      }
    }
  }
};

// for...of
for (let val of array) {
  console.log(val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
class Equipments{
  static loricae(hero){
    hero.defence += 15;
    hero.hp += 200;
  }
  static glaive(hero){
    hero.attcak += 40;
  }
}

class Hero {
  constructor({def = 30,atk = 70,hp = 630} = {}) {
    this.hp = hp;
    this.attcak = atk;
    this.defence = def;
  }

  toString() {
    return `防御力:${this.defence},攻击力:${this.attcak},血量:${this.hp}`;;
  }
}

let hero = new Hero();
console.log(hero); //{&quot;hp&quot;:630,&quot;attcak&quot;:70,&quot;defence&quot;:30}

Equipments.loricae(hero)
console.log(hero); //{&quot;hp&quot;:830,&quot;attcak&quot;:70,&quot;defence&quot;:45}

Equipments.glaive(hero)
console.log(hero); //{&quot;hp&quot;:830,&quot;attcak&quot;:110,&quot;defence&quot;:45}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;订阅发布模式&quot;&gt;订阅/发布模式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;发布-订阅（publish–subscribe）是一种消息传播模式，消息的发送者（发布者）不会将消息直接发送给特定的接收者（订阅者）。而是将发布的消息按特征分类，无需对订阅者（如果有的话）有所了解。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需对发布者（如果有的话）有所了解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
class Event {
  constructor() {
    this.subscribers = new Map([['any', []]]);
  }

  on(type = 'any',fn) {
    let subs = this.subscribers;
    if (!subs.get(type)) return subs.set(type, [fn]);
    subs.set(type, (subs.get(type).push(fn)));
  }

  emit(type = 'any', ...agrs) {
    for (let fn of this.subscribers.get(type)) {
      fn(...agrs);
    }
  }
}

let event = new Event();

event.on(&quot;click&quot;,(e) =&amp;gt; console.log(`click Dom: ${e.target}`));
event.emit('click',{target:&quot;div&quot;}); //click Dom: div
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;命令模式&quot;&gt;命令模式&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;命令模式将一个请求或者操作封装到一个对象中。命令模式将发出命令和执行命令的责任分割开，委派给不同的对象。命令模式也允许请求方个接受方相互独立，使得请求方不需要知道接收方的接口等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;e.g.在富文本编辑器中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;'use strict';
class Cmd{
  constructor(){
    this.execList=[];
    this.cmds={
      blod:function(){},
      font_family:function(){},
      font_color:function(){},
      code:function(){}
      //等等
      };//命令集合
  }
  exec(cmd,...args){
    let command = this.cmds[cmd];
    if(command){
      this.execList.push({
        cmd:cmd,
        args:args
      });
      command(args)
    }

  }

  undo(){
    let handle = this.execList.pop();
    console.log(handle)
    //do something;
  }
}

let cmd=new Cmd()
cmd.exec(&quot;blod&quot;);
cmd.exec(&quot;code&quot;,&quot;let a;&quot;);
cmd.undo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先介绍这么多。。有时间在更新吧！&lt;/p&gt;
</description>
				<pubDate>Mon, 30 Nov 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/11/30/es6_Design-pattern</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/11/30/es6_Design-pattern</guid>
			</item>

			<item>
				<title>ES7 Decorator 装饰者模式 浅出</title>
				<description>&lt;h2 id=&quot;es6-已经来了es7-还会远么&quot;&gt;ES6 已经来了，ES7 还会远么？&lt;/h2&gt;

&lt;p&gt;ES6 标准正式发布，众多新特性成为标准固然另人激动，然而更值得憧憬的还是未来。所以，让我们来看看 ES7（更正式的说法是 ES2016）有哪些激动人心的变化。最为人津津乐道的可能就是 async/await 了，不过我个人出对 decorator 模式有点感兴趣，本文尝试对此做一个介绍。&lt;/p&gt;

&lt;h3 id=&quot;decorator-是什么&quot;&gt;decorator 是什么&lt;/h3&gt;

&lt;p&gt;ES7 的 decorator 概念是从 Python 借来的，在 Python 里，decorator 实际上是一个 wrapper，它作用于一个目标函数，对这个目标函数做一些额外的操作，然后返回一个新的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def my_decorator(fn):
  def inner(name):
    print 'Hello ' + fn(name)
  return inner

@my_decorator
def greet(name):
  return name

greet('Decorator!')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种 @decorator 的写法其实是一种语法糖，从 &lt;code&gt;my_decorator&lt;/code&gt;的定义就可以看出，它接收一个函数（ fn ）为参数，定义一个新的内部函数（ innner ），这个内部函数会定义一些行为，最后 &lt;code&gt;my_decorator&lt;/code&gt; 返回这个内部函数（ inner ）。&lt;/p&gt;

&lt;p&gt;上面的 &lt;code&gt;@my_decorator&lt;/code&gt;等于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;greet = my_decorator(greet)

greet('Decorator!')

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;hello-decorator&quot;&gt;Hello Decorator!&lt;/h2&gt;

&lt;p&gt;ES7 中的 decorator 同样借鉴了这个语法糖，不过依赖于 ES5 的 Object.defineProperty 方法 。&lt;/p&gt;

&lt;h2 id=&quot;浅出&quot;&gt;浅出&lt;/h2&gt;

&lt;p&gt;想必大家都该玩过LOL吧。那么我就以英雄联盟英雄为例子。&lt;/p&gt;

&lt;p&gt;##第一步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;英雄&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;class Hero{
  constructor(def = 30,atk = 70,hp = 630){
    this.init({def,atk,hp});
  }
  init({def,atk,hp}){
    this.hp=hp;
    this.attcak=atk;
    this.defence=def;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;德玛西亚 ps：这只是个小德玛，简单的继承了英雄属性而已，没特色啊，防御和血量哪去了。。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;class 德玛西亚 extends Hero{
  init(args){
    super.init(args);
  }
  toString(){
    return `防御力:${this.defence},攻击力:${this.attcak},血量:${this.hp}`;
  }
}
var _德玛西亚 = new 德玛西亚();

console.log(`当前状态 ===&amp;gt; ${_德玛西亚}`);
// 当前状态 ===&amp;gt; 防御力:30,攻击力:70,血量:630
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##第二步&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化德玛属性&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function 德玛西亚初始(target, key, descriptor) {
  const method = descriptor.value;
  let moreHP = 150;
  let ret;
  descriptor.value = ({def,atk,hp})=&amp;gt;{
    hp+=moreHP;
    ret = target::method({def,atk,hp});
    return ret;
  }
  return descriptor;
}

class 德玛西亚 extends Hero{
  @德玛西亚初始;
  init(args){
    super.init(args);
  }
  toString(){
    return `防御力:${this.defence},攻击力:${this.attcak},血量:${this.hp}`;
  }
}
var _德玛西亚 = new 德玛西亚();

console.log(`当前状态 ===&amp;gt; ${_德玛西亚}`);
// 当前状态 ===&amp;gt; 防御力:30,攻击力:70,血量:780
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;血量变多了。还好吧，那下一步给他个被动技能吧！&lt;/p&gt;

&lt;p&gt;####这里可能会有两个疑问：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;德玛西亚初始&lt;/code&gt;方法的参数为啥是这三个？可以更换么？&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;德玛西亚初始&lt;/code&gt;方法为什么返回的是descriptor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;####这里给出的解答作为参考：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;Decorators 的本质是利用了ES5的 Object.defineProperty 属性，这三个参数其实是和 Object.defineProperty参数一致的，因此不能更改。可以看看 bable转换后 的代码，其中有一句是descriptor = decorator(target, key, descriptor)&lt;/td&gt;
        &lt;td&gt; &lt;/td&gt;
        &lt;td&gt;descriptor;，点到为止，这里不详细展开了，可自行看看这行代码的上下文&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;初始化德玛西亚的被动技能&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;

function 德玛被动() {
  return function(target){
    let extra = '(技能加成:盖伦在7秒内不受到任何伤害之后，每秒回复最大生命值的0.5% )';
    let method = target.prototype.toString;
    target.prototype.toString = (...args)=&amp;gt;{
      return target.prototype::method(args) + extra;
    }
    return target;
  }
}

@德玛被动()
class 德玛西亚 extends Hero{
  @德玛西亚初始;
  init(args){
    super.init(args);
  }
  toString(){
    return `防御力:${this.defence},攻击力:${this.attcak},血量:${this.hp}`;
  }
}
var _德玛西亚 = new 德玛西亚();

console.log(`当前状态 ===&amp;gt; ${_德玛西亚}`);
// 当前状态 ===&amp;gt; 防御力:30,攻击力:70,血量:780(技能加成:盖伦在7秒内不受到任何伤害之后，每秒回复最大生命值的0.5% )

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好啦完整的德玛西亚出来了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码直接放在 &lt;a href=&quot;&quot;&gt;http://babeljs.io/repl/&lt;/a&gt; 中运行查看结果，记得勾选Experimental选项和Evaluate选项&lt;/p&gt;
&lt;/blockquote&gt;

</description>
				<pubDate>Mon, 23 Nov 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/11/23/es7_decorator</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/11/23/es7_decorator</guid>
			</item>

			<item>
				<title>requestAnimationFrame 详解</title>
				<description>&lt;p&gt;浏览器中动画有两种实现形式：通过申明元素实现（如SVG中的元素）和脚本实现。&lt;/p&gt;

&lt;p&gt;可以通过setTimeout和setInterval方法来在脚本中实现动画，但是这样效果可能不够流畅，且会占用额外的资源。可参考&lt;a href=&quot;http://book.douban.com/subject/24533314/&quot;&gt;《Html5 Canvas核心技术》&lt;/a&gt;中的论述：&lt;/p&gt;

&lt;p&gt;它们有如下的特征：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有对调用动画的循环机制进行优化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有考虑到绘制动画的最佳时机，只是一味地以某个大致的事件间隔来调用循环。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;jQuery动画的实现考虑到兼容与易用性采用了setInterval来不断绘制新的属性值，从而达到动画的效果。&lt;/p&gt;

&lt;p&gt;大部分浏览器的显示频率是16.7ms，由于浏览器的特性，setInterval会有一个丢帧的问题&lt;/p&gt;

&lt;p&gt;即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞&lt;/p&gt;

&lt;p&gt;jQuery会有一个全局设置&lt;code&gt;jQuery.fx.interval = 13&lt;/code&gt;设置动画每秒运行帧数。&lt;/p&gt;

&lt;p&gt;默认是13毫秒。该属性值越小，在速度较快的浏览器中（例如，Chrome），动画执行的越流畅，但是会影响程序的性能并且占用更多的 CPU 资源&lt;/p&gt;

&lt;p&gt;那么归纳一点最关键的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;开发着并不知道下一刻绘制动画的最佳时机是什么时候&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt; 是专门为实现高性能的帧动画而设计的一个API&lt;/p&gt;

&lt;p&gt;说简单点&lt;/p&gt;

&lt;p&gt;setInterval、setTimeout是开发者主动要求浏览器去绘制，但是由于种种问题，浏览器可能会漏掉部分命令
requestAnimationFrame 就是浏览器什么要开始绘制了浏览器自己知道，通过requestAnimationFrame 告诉开发者，这样就不会出现重复绘制丢失的问题了
目前已在多个浏览器得到了支持，包括IE10+，Firefox，Chrome，Safari，Opera等，在移动设备上，ios6以上版本以及IE mobile 10以上也支持requestAnimationFrame，&lt;/p&gt;

&lt;p&gt;唯一比较遗憾的是目前安卓上的原生浏览器并不支持requestAnimationFrame，不过对requestAnimationFrame的支持应该是大势所趋了，安卓版本的chrome 16+也是支持requestAnimationFrame的。&lt;/p&gt;

&lt;h3 id=&quot;那么如何给动画设置帧数呢&quot;&gt;那么如何给动画设置帧数呢？&lt;/h3&gt;

&lt;h4 id=&quot;最简单&quot;&gt;最简单：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;
var FPS = 60;

setInterval(draw, 1000/FPS);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个简单做法，如果draw带有大量逻辑计算，导致计算时间超过帧等待时间时，将会出现丢帧。除外，如果FPS太高，超过了当时浏览器的重绘频率，将会造成计算浪费，例如浏览器实际才重绘2帧，但却计算了3帧，那么有1帧的计算就浪费了。&lt;/p&gt;

&lt;h4 id=&quot;成熟做法&quot;&gt;成熟做法：&lt;/h4&gt;

&lt;p&gt;引入requestAnimationFrame，这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。&lt;/p&gt;

&lt;p&gt;这个函数类似setTimeout，只调用一次。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function draw() {
        requestAnimationFrame(draw);
        // ... Code for Drawing the Frame ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归调用，就可以实现定时器。&lt;/p&gt;

&lt;p&gt;但是，这样完全跟浏览器帧频同步了，无法自定义动画的帧频，是无法满足需求的。&lt;/p&gt;

&lt;p&gt;接下来需要考虑如何控制帧频。&lt;/p&gt;

&lt;h4 id=&quot;简单做法&quot;&gt;简单做法：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var fps = 30;
function tick() {
　　setTimeout(function() {
　　　　requestAnimationFrame(tick);
　　　　draw(); // ... Code for Drawing the Frame ...
　　}, 1000 / fps);
}
tick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种做法，比较直观的可以发现，每一次setTimeout执行的时候，都还要再等到下一个requestAnimationFrame事件到达，累积下去会造成动画变慢。&lt;/p&gt;

&lt;h4 id=&quot;自行控制时间跨度&quot;&gt;自行控制时间跨度：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var fps = 30;
var now;
var then = Date.now();
var interval = 1000/fps;
var delta;

function tick() {
　　requestAnimationFrame(tick);
　　now = Date.now();
　　delta = now - then;
　　if (delta &amp;gt; interval) {
　　　　// 这里不能简单then=now，否则还会出现上边简单做法的细微时间差问题。
　　　　// 例如fps=10，每帧100ms，而现在每16ms（60fps）执行一次draw。16*7=112&amp;gt;100，需要7次才实际绘制一次。
　　　　// 这个情况下，实际10帧需要112*10=1120ms&amp;gt;1000ms才绘制完成。
　　　　then = now - (delta % interval);
　　　　draw(); // ... Code for Drawing the Frame ...
　　}
}
tick();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;针对低版本浏览器再优化&quot;&gt;针对低版本浏览器再优化：&lt;/h4&gt;

&lt;p&gt;如果浏览器没有requestAnimationFrame函数，实际底层还只能用setTimeout模拟，上边做的都是无用功。那么可以再改进一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var fps = 30;
var now;
var then = Date.now();
var interval = 1000/fps;
var delta;
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

function tick() {
　　if(window.requestAnimationFrame)
   {
　　    requestAnimationFrame(tick);
　　    now = Date.now();
　　    delta = now - then;
　　    if (delta &amp;gt; interval) {
        // 这里不能简单then=now，否则还会出现上边简单做法的细微时间差问题。例如fps=10，每帧100ms，而现在每16ms（60fps）执行一次draw。16*7=112&amp;gt;100，需要7次才实际绘制一次。这个情况下，实际10帧需要112*10=1120ms&amp;gt;1000ms才绘制完成。
　　　　    then = now - (delta % interval);
　　　　    draw(); // ... Code for Drawing the Frame ...
　　    }
   }
   else
   {
       setTimeout(tick, interval);
　　　　draw();
   }
}
tick();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，还可以加上暂停。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var fps = 30;
var pause = false;
var now;
var then = Date.now();
var interval = 1000/fps;
var delta;
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

function tick() {
     if(pause)
          return;
 　　if(window.requestAnimationFrame)
     {
　　　　...
     }
     else
     {
          ...
     }
}
tick();
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Tue, 10 Nov 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/11/10/requestAnimationFrame</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/11/10/requestAnimationFrame</guid>
			</item>

			<item>
				<title>BFC 神奇背后的原理</title>
				<description>&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;已经是一个耳听熟闻的词语了，网上有许多关于&lt;code&gt;BFC&lt;/code&gt;的文章，介绍了如何触发&lt;code&gt;BFC&lt;/code&gt;， 以及&lt;code&gt;BFC&lt;/code&gt;的一些用处（如清浮动，防止margin重叠等）。虽然我知道如何利用&lt;code&gt;BFC&lt;/code&gt;解决这些问题，但当别人问我&lt;code&gt;BFC&lt;/code&gt;是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec, 和许多文章，来全面地理解BFC：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt; BFC&lt;/code&gt;是个什么？&lt;/li&gt;
  &lt;li&gt;哪些元素会生成&lt;code&gt;BFC&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;的神奇的作用，及背后的原理&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一bfc是什么&quot;&gt;一、BFC是什么？&lt;/h2&gt;

&lt;p&gt;在解释&lt;code&gt;BFC&lt;/code&gt;是什么之前，需要先介绍&lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Formatting context&lt;/code&gt;的概念。&lt;/p&gt;

&lt;h3 id=&quot;box-css布局的基本单位&quot;&gt;Box: CSS布局的基本单位&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Box&lt;/code&gt;是CSS布局的对象和基本单位， 直观点来说，就是一个页面是由很多个&lt;code&gt;Box&lt;/code&gt;组成的。元素的类型和display属性，决定了这个&lt;code&gt;Box&lt;/code&gt;的类型。 不同类型的&lt;code&gt;Box&lt;/code&gt;， 会参与不同的&lt;code&gt;Formatting context&lt;/code&gt;(一个决定如何渲染文档的容器)，因此&lt;code&gt;Box&lt;/code&gt;内的元素会以不同的方式渲染。让我们看看有哪些盒子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;block-level box&lt;/code&gt;: display属性为block, list-item, table的元素，会生成&lt;code&gt;block-level box&lt;/code&gt;。并且参与&lt;code&gt;block fomatting context&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;inline-level box&lt;/code&gt;: display属性为inline, inline-block, inline-table的元素，会生成&lt;code&gt;inline-level box&lt;/code&gt;。并且参与&lt;code&gt;inline formatting context&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;run-in box&lt;/code&gt;: css3中才有， 这儿先不讲了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;formatting-context&quot;&gt;Formatting context&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Formatting context&lt;/code&gt;是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。&lt;/p&gt;

&lt;p&gt;最常见的&lt;code&gt;Formatting context&lt;/code&gt;有&lt;code&gt;Block fomatting context&lt;/code&gt;(简称&lt;code&gt;BFC&lt;/code&gt;)和&lt;code&gt;Inline formatting context&lt;/code&gt;(简称&lt;code&gt;IFC&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;CSS2.1 中只有&lt;code&gt;BFC&lt;/code&gt;和&lt;code&gt;IFC&lt;/code&gt;, CSS3中还增加了&lt;code&gt;GFC&lt;/code&gt;和&lt;code&gt;FFC&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;bfc-定义&quot;&gt;BFC 定义&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;(&lt;code&gt;Block formatting context&lt;/code&gt;)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有&lt;code&gt;Block-level box&lt;/code&gt;参与， 它规定了内部的&lt;code&gt;Block-level Box&lt;/code&gt;如何布局，并且与这个区域外部毫不相干。&lt;/p&gt;

&lt;h4 id=&quot;bfc布局规则&quot;&gt;BFC布局规则：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;内部的&lt;code&gt;Box&lt;/code&gt;会在垂直方向，一个接一个地放置。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Box&lt;/code&gt;垂直方向的距离由margin决定。属于同一个&lt;code&gt;BFC&lt;/code&gt;的两个相邻&lt;code&gt;Box&lt;/code&gt;的margin会发生重叠&lt;/li&gt;
  &lt;li&gt;每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;的区域不会与&lt;code&gt;float box&lt;/code&gt;重叠。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BFC&lt;/code&gt;就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&lt;/li&gt;
  &lt;li&gt;计算&lt;code&gt;BFC&lt;/code&gt;的高度时，浮动元素也参与计算&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二哪些元素会生成bfc&quot;&gt;二、哪些元素会生成BFC?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;根元素&lt;/li&gt;
  &lt;li&gt;float属性不为none&lt;/li&gt;
  &lt;li&gt;position为absolute或fixed&lt;/li&gt;
  &lt;li&gt;display为inline-block, table-cell, table-caption, flex, inline-flex&lt;/li&gt;
  &lt;li&gt;overflow不为visible&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三bfc的作用及原理&quot;&gt;三、BFC的作用及原理&lt;/h2&gt;

&lt;h3 id=&quot;1-自适应两栏布局&quot;&gt;1. 自适应两栏布局&lt;/h3&gt;
&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style&amp;gt;
    body {
        width: 300px;
        position: relative;
    }

    .aside {
        width: 100px;
        height: 150px;
        float: left;
        background: #f66;
    }

    .main {
        height: 200px;
        background: #fcc;
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;aside&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;main&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.qhimg.com/d/inn/4055c62a/4dca44a927d4c1ffc30e3ae5f53a0b79.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第3条：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第四条：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;的区域不会与&lt;code&gt;float box&lt;/code&gt;重叠。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以通过通过触发main生成&lt;code&gt;BFC&lt;/code&gt;， 来实现自适应两栏布局。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.main {
    overflow: hidden;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当触发main生成&lt;code&gt;BFC&lt;/code&gt;后，这个新的&lt;code&gt;BFC&lt;/code&gt;不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p6.qhimg.com/t01077886a9706cb26b.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-清除内部浮动&quot;&gt;2. 清除内部浮动&lt;/h3&gt;

&lt;p&gt;代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style&amp;gt;
    .par {
	    border: 5px solid #fcc;
	    width: 300px;
    }

    .child {
	    border: 5px solid #f66;
	    width:100px;
	    height: 100px;
	    float: left;
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;par&quot;&amp;gt;
	    &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
	    &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p1.qhimg.com/t016035b58195e7909a.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第六条：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;计算&lt;code&gt;BFC&lt;/code&gt;的高度时，浮动元素也参与计算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为达到清除内部浮动，我们可以触发par生成&lt;code&gt;BFC&lt;/code&gt;，那么par在计算高度时，par内部的浮动元素child也会参与计算。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.par {
    overflow: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p2.qhimg.com/t016bbbe5236ef1ffd5.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;
￼&lt;/p&gt;
&lt;h3 id=&quot;3-防止垂直margin重叠&quot;&gt;3. 防止垂直margin重叠&lt;/h3&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style&amp;gt;
    p {
        color: #f55;
        background: #fcc;
        width: 200px;
        line-height: 100px;
        text-align:center;
        margin: 100px;
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Haha&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;Hehe&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p5.qhimg.com/t01b47b8b7d153c07cc.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两个p之间的距离为100px，发送了margin重叠。&lt;br /&gt;
根据BFC布局规则第二条：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Box&lt;/code&gt;垂直方向的距离由margin决定。属于同一个&lt;code&gt;BFC&lt;/code&gt;的两个相邻&lt;code&gt;Box&lt;/code&gt;的margin会发生重叠&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以在p外面包裹一层容器，并触发该容器生成一个&lt;code&gt;BFC&lt;/code&gt;。那么两个P便不属于同一个&lt;code&gt;BFC&lt;/code&gt;，就不会发生margin重叠了。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style&amp;gt;
    .wrap {
        overflow: hidden;
    }
    p {
        color: #f55;
        background: #fcc;
        width: 200px;
        line-height: 100px;
        text-align:center;
        margin: 100px;
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Haha&amp;lt;/p&amp;gt;
    &amp;lt;div class=&quot;wrap&quot;&amp;gt;
        &amp;lt;p&amp;gt;Hehe&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p3.qhimg.com/t0118d1d2badbb00521.png&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实以上的几个例子都体现了&lt;code&gt;BFC&lt;/code&gt;布局规则第五条：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为&lt;code&gt;BFC&lt;/code&gt;内部的元素和外部的元素绝对不会互相影响，因此， 当&lt;code&gt;BFC&lt;/code&gt;外部存在浮动时，它不应该影响&lt;code&gt;BFC&lt;/code&gt;内部Box的布局，&lt;code&gt;BFC&lt;/code&gt;会通过变窄，而不与浮动有重叠。同样的，当&lt;code&gt;BFC&lt;/code&gt;内部有浮动时，为了不影响外部元素的布局，&lt;code&gt;BFC&lt;/code&gt;计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/melonHuang/blog/blob/master/docs/css/1formattingContext.md&quot;&gt;转自 奇舞团&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
				<pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/05/14/css_BFC</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/05/14/css_BFC</guid>
			</item>

			<item>
				<title>前端性能优化实践</title>
				<description>&lt;p&gt;##高频执行事件/方法的防抖&lt;/p&gt;

&lt;p&gt;通常，开发人员会在有用户交互参与的地方添加事件，而往往这种事件会被频繁触发。想象一下窗口的resize事件或者是一个元素的onmouseover事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。这就是为什么我们要引入防抖。&lt;/p&gt;

&lt;p&gt;防抖可以限制一个方法在一定时间内执行的次数。以下代码是个防抖示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// 取自 UnderscoreJS 实用框架
function debounce(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate &amp;amp;&amp;amp; !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
  }

// 添加resize的回调函数，但是只允许它每300毫秒执行一次
window.addEventListener('resize', debounce(function(event) {

    // 这里写resize过程

}, 300));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;debounce方法返回一个方法，用来包住你的回调函数，限制他的执行频率。使用这个防抖方法，就可以让你写的频繁回调的方法不会妨碍用户的浏览器！&lt;/p&gt;

&lt;p&gt;##尽可能使用CSS动画&lt;/p&gt;

&lt;p&gt;网站设计对美观特性和可配置元素动画的大量需求，使得一些JavaScript类库，如jQuery，MooTools大量的被使用。尽管现在浏览器支持CSS的transformation和keyframe所做的动画，现在仍有很多人使用JavaScript制作动画效果，但是实际上使用CSS动画比起JavaScript驱动的动画效率更高。CSS动画同时需要更少的代码。很多的CSS动画是用GPU处理的，因此动画本身很流畅，当然你可以使用下面这个简单的CSS强制使你的硬件加速：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.myAnimation {
    animation: someAnimation 1s;
    transform: translate3d(0, 0, 0); /* 强制硬件加速 */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tansform:transform(0,0,0)在不会影响其他动画的同时将通话送入硬件加速。在不支持CSS动画的情况下（IE8及以下版本的浏览器），你可以引入JavaScript动画逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--[if 低于IE8版本]&amp;gt;
&amp;lt;script src=&quot;http://code.jquery.com/jquery-1.9.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;/js/ie-animations.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上例中，ie-animations.JS文件必须包含你自定义的jQuery代码，用于当CSS动画在早期IE中不被支持的情况下，来替代CSS动画完成动画效果。完美的通过CSS动画来优化动画，通过JavaScript来支持全局动画效果。&lt;/p&gt;

&lt;p&gt;##使用媒体查询加载指定大小的背景图片&lt;/p&gt;

&lt;p&gt;直到CSS @supports被广泛支持，CSS媒体查询的使用接近于CSS中写逻辑控制。我们经常用CSS媒体查询来根据设备调整CSS属性（通常根据屏幕宽度调整CSS属性），例如根据不同的屏幕宽度来设置不同的元素宽度或者是悬浮位置。那么我们为什么不用这种方式来改变背景图片呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* 默认是为桌面应用加载图片 */
.someElement { background-image: url(sunset.jpg); }

@media only screen and (max-width : 1024px) {
    .someElement { background-image: url(sunset-small.jpg); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码片段是为手机设备或是类似的移动设备加载一个较小尺寸的图片，特别是需要一个特别小的图片时（例如图片的大小几乎不可视）。&lt;/p&gt;

&lt;p&gt;##控制DOM大小&lt;/p&gt;

&lt;p&gt;DOM很慢是众所周知的，使得网站变慢的罪魁祸首是大量的DOM。想象一下，假如你有一个有着上千节点的DOM，在想象一下，使用querySelectorAll或者getElementByTagName，或者是其他以DOM为中心的搜索方式来搜索一个节点，即使是使用内置方法，这也将是一个非常费力的过程。你要知道，多余的DOM节点会使其他的实用程序也变慢的。&lt;/p&gt;

&lt;p&gt;我见过的一种情况，DOM的大小悄然增加，是在一个AJAX网站，它将所有的页面都存在了DOM中，当一个新的页面通过AJAX被加载时，旧的页面就会被存入隐藏的DOM节点。对于DOM的速度，将有灾难性的降低，特别是当一个页面是动态加载的。所以你需要一种更好的方法。&lt;/p&gt;

&lt;p&gt;在这种情况下，当页面是通过AJAX加载的，并且以前的页面是存储在客户端的，最好的方法就是将内容通过String HTML存储（将内容从DOM中移除），然后使用事件委托来避免特定元素事件。这么做的同时，当在客户端缓存内容的时候，可以避免大量的DOM生成。&lt;/p&gt;

&lt;p&gt;通常控制DOM大小的技巧包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用:before和:after伪元素&lt;/li&gt;
  &lt;li&gt;延迟加载和呈现内容&lt;/li&gt;
  &lt;li&gt;使用事件委托，更简便的将节点转换成字符串存储&lt;/li&gt;
  &lt;li&gt;简单一句话：尽量使你的DOM越小越好。&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Tue, 12 May 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/05/12/js-opt</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/05/12/js-opt</guid>
			</item>

			<item>
				<title>2015年值得关注的几个WEB技术</title>
				<description>&lt;p&gt;&lt;strong&gt;HTTP2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP2在今年中应该就可以定稿，这无疑是web界的一个大事。HTTP2从google的SPDY中借鉴了很多特性，重点改善了之前HTTP协议在当前的网络环境下的性能。简单地来讲，HTTP2更快。为什么呢，有几个主要改变：&lt;/p&gt;

&lt;p&gt;首先是来自于同一个domain的HTTP请求可以共享同一个TCP连接了，这样可以很大程度上解决网络延时带来的性能问题。比如你有很多图片，现在也不用sprite化了，因为反正它们会用同一个连接的。HTTP2的出现让之前的很多web前端优化技术可能不再需要了。
HTTP2不再是纯文本的了，而是二进制的协议了，这样协议的解析也更简单，而传输也更快。缺点是debug的时候需要费点功夫了。
HTTP2还有其他一些特性，例如header压缩等，大家可以到&lt;a href=&quot;http://daniel.haxx.se/http2/&quot;&gt;这里&lt;/a&gt;集中学习一下。或者看看这个&lt;a href=&quot;http://http2.github.io/faq/&quot;&gt;FAQ&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Firefox已经开始支持HTTP2，不少浏览器包括chrome之前就支持SPDY，估计对HTTP2的支持也会迅速开始，而nginx目前已经支持SPDY，就看什么时候各大主流web服务器开始支持HTTP2了。&lt;/p&gt;

&lt;p&gt;一个不太好的现状就是开发人员可能得面临HTTP2和HTTP 1.1的同时存在。如果享受HTTP2的好处，同时又能向后兼容HTTP1.1，可能是今后开发人员必须长期面临的问题了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ECMAScript6&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们现在用的javascript（注意，是javascript语言本身，不包含DOM等其他东西）背后的标准是ECMA-262，也叫ECMAScript 5。它的下一个版本ECMAScript 6（简称es6），已经基本上快定稿了。这个版本里加入了很多开发过程中需要的一些功能，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;类定义语法，包括super，继承&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lambda风格的函数定义，&lt;code&gt;=&amp;gt;&lt;/code&gt; block level函数定义内的lexical scope的&lt;code&gt;this&lt;/code&gt;，默认参数，rest参数等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;destructuring, 类似于ruby里的 &lt;code&gt;[a, b, c] = [1, 2, 3]&lt;/code&gt;，同时也适用于map和set，以及函数参数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;symbol&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;iterator迭代器和generator，以及新的for of循环语法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;template string，从此可以像在ruby和shell里一样使用多行字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;module语法，从语言层面上支持了模块&lt;/li&gt;
  &lt;li&gt;另外还有一系列新东西例如promise，proxy，unicode支持等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前chrome和firefox已经开始逐步支持es6。不过你不用等到所有浏览器都开始支持es6后才可以使用它，因为目前已经有很多把es6代码编译成es5代码的工具，例如babel和traceur等。有很多js的库已经开始使用es6的各种功能了，其中包括angular 2.0。&lt;/p&gt;

&lt;p&gt;很多人应该在用coffeescript，es6的很多功能弥补了之前es5的缺陷，吸收了很多coffeescript的功能，也许以后我们就可以不用coffeescript了，除非你不喜欢大括号小括号，而喜欢python的语法。不过如果coffeescript不进行升级，估计就享受不到将来es6带来的好处，也难以适应HTML5时代各种数值计算的需求。&lt;/p&gt;

&lt;p&gt;最后给大家一个比较不错的&lt;a href=&quot;https://leanpub.com/understandinges6/read&quot;&gt;es6学习资源&lt;/a&gt;，这本书写得很细，现在还是在线免费的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Immutable js and React&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;React相信大家已经不陌生了，它是facebook开源的一个前端view框架，这里之所以提到它是因为它背后的理念所带动的一些技术。React本身虽然只是一个view框架，但是背后的virtual dom以及随之带来的性能优势是吸引人的地方，另外就是它采用的类似web component的封装概念。这里有一个比较js前端框架性能的&lt;a href=&quot;http://evancz.github.io/todomvc-perf-comparison/&quot;&gt;试验&lt;/a&gt;，虽然不是很准确，但是可以作一个参考。&lt;/p&gt;

&lt;p&gt;React的virtual dom以及它管理前端控件数据的方法，和immutable数据结构（immuatble js， remutable）、functional programming是可以很容易结合起来使用的。clojurescript的om框架就是一个例子。想象一下所有的状态都是不可变的，并且统一数据存储（flux架构例如&lt;a href=&quot;http://martyjs.org/&quot;&gt;marty&lt;/a&gt;），每次数据的更新都可以很容易只&lt;a href=&quot;https://blog.rotenberg.io/flux-over-the-wire-3/&quot;&gt;传递diff&lt;/a&gt;（event source模式），整个数据在前端的流动都是单向的，不仅变成模型变得简单，而且因为所有的历史数据都没有被实际修改过，所以undo和redo的实现也会变得很容易。&lt;/p&gt;

&lt;p&gt;React通过virtual dom实现了immediate模式的UI编程，低成本和快速的UI刷新也带了人们更多启发，并且React这种封装方式也变得不局限于dom view了。例如flipboard团队基于React的封装风格在canvas上封装了一层UI，可以实现精细的动画效果，保证web版和移动版的体验一致。facebook的React团队最近在React会议上也发布了一个可以用js和React API进行原生移动开发的框架。&lt;/p&gt;

&lt;p&gt;React也许只是另外一个web view框架，但是我喜欢它给我带来的一些新想法，这些想法也许可以让我们在前端开发上更容易些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Realtime web（实时web技术）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在的web对实时性要求越来越高，这不光是由于现在的技术可以更好地支持实时性，也是由于用户体验的驱动。实时性不光是体现在聊天这种需求上；我们在手机上的操作，web浏览器上最好能够实时体现出来，即便我们不刷新页面，页面也应该能够实时得到更新。&lt;/p&gt;

&lt;p&gt;前端由于HTML5的出现对于实时需求有了更好的技术支持，例如新的WebSocket、WebRTC，long polling以及server push技术。而后端则早就出现了async IO编程技术，能够同时支持大量长连接。但是这些技术的进步从来没有停止过，这里给大家随便介绍几个。&lt;/p&gt;

&lt;p&gt;pushpin是fanout最近开源的一个高性能实时web后端技术，不同于其它的技术，它是一个proxy，本身不提供API编程框架，而是和已有的web API结合起来，让它们变成支持大量长连接的API。从设计概念上，它把维护大量长连接这个功能和实际的API业务功能分离开来，让前一个功能通过proxy的形式来实现，因此对实际API的框架和语言没有要求，如果要支持更多长连接，也可以通过横向扩展这个proxy来实现，而不一定要改动后端API。&lt;/p&gt;

&lt;p&gt;sockjs，是一个websocket的模拟，在支持websocket的浏览器上就会使用原生websocket，而在老的浏览器上则提供替代技术。但是它不止是一个前端js库，它也同时提供了后端的编程框架，目前支持的语言和框架挺多了。&lt;/p&gt;

&lt;p&gt;websocketd是一个有意思的东西，它可以把任何符合接口的程序编程一个websocket后端，你甚至可以用shell来写API。&lt;/p&gt;

&lt;p&gt;很多的web框架都支持异步编程模式，因而可以支持大量并发长连接。也有类似于meteor这种提供整体解决方案的，还有很多近期的firebase，大家有兴趣可以自己去找找看。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/d31cc869bd54#&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 29 Apr 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/04/29/learn-web</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/04/29/learn-web</guid>
			</item>

			<item>
				<title>HTTP API 设计指南</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;翻译自 &lt;code&gt;HTTP API Design Guide&lt;/code&gt; &lt;a href=&quot;https://github.com/interagent/http-api-design&quot;&gt;https://github.com/interagent/http-api-design&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 &lt;a href=&quot;https://devcenter.heroku.com/articles/platform-api-reference&quot;&gt;Heroku 平台 API 指引&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。&lt;/p&gt;

&lt;p&gt;我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。&lt;/p&gt;

&lt;p&gt;我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。&lt;/p&gt;

&lt;p&gt;我们欢迎你为这篇指南做&lt;a href=&quot;https://github.com/interagent/http-api-design/blob/master/CONTRIBUTING.md&quot;&gt;贡献&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;基础
    &lt;ul&gt;
      &lt;li&gt;强制使用安全连接（Secure Connections）&lt;/li&gt;
      &lt;li&gt;强制头信息 Accept 中提供版本号&lt;/li&gt;
      &lt;li&gt;支持Etag缓存&lt;/li&gt;
      &lt;li&gt;为内省而提供 Request-Id&lt;/li&gt;
      &lt;li&gt;通过请求中的范围（Range）拆分大的响应&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;请求（Requests）
    &lt;ul&gt;
      &lt;li&gt;返回合适的状态码&lt;/li&gt;
      &lt;li&gt;提供全部可用的资源&lt;/li&gt;
      &lt;li&gt;在请求的body体使用JSON格式数据&lt;/li&gt;
      &lt;li&gt;使用统一的资源路径格式&lt;/li&gt;
      &lt;li&gt;路径和属性要小写&lt;/li&gt;
      &lt;li&gt;支持方便的无id间接引用&lt;/li&gt;
      &lt;li&gt;最小化路径嵌套&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;响应（Responses）
    &lt;ul&gt;
      &lt;li&gt;提供资源的(UU)ID&lt;/li&gt;
      &lt;li&gt;提供标准的时间戳&lt;/li&gt;
      &lt;li&gt;使用UTC（世界标准时间）时间，用ISO8601进行格式化&lt;/li&gt;
      &lt;li&gt;嵌套外键关系&lt;/li&gt;
      &lt;li&gt;生成结构化的错误&lt;/li&gt;
      &lt;li&gt;显示频率限制状态&lt;/li&gt;
      &lt;li&gt;保证响应JSON最小化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工件（Artifacts）
    &lt;ul&gt;
      &lt;li&gt;提供机器可读的JSON模式&lt;/li&gt;
      &lt;li&gt;提供人类可读的文档&lt;/li&gt;
      &lt;li&gt;提供可执行的例子&lt;/li&gt;
      &lt;li&gt;描述稳定性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;译者注&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基础&quot;&gt;基础&lt;/h3&gt;

&lt;h4 id=&quot;隔离关注点&quot;&gt;隔离关注点&lt;/h4&gt;
&lt;p&gt;设计时通过将请求和响应之间的不同部分隔离来让事情变得简单。保持简单的规则让我们能更关注在一些更大的更困难的问题上。&lt;/p&gt;

&lt;p&gt;请求和响应将解决一个特定的资源或集合。使用路径（path）来表明身份，body来传输内容（content）还有头信息（header）来传递元数据（metadata）。查询参数同样可以用来传递头信息的内容，但头信息是首选，因为他们更灵活、更能传达不同的信息。&lt;/p&gt;

&lt;h4 id=&quot;强制使用安全连接secure-connections&quot;&gt;强制使用安全连接（Secure Connections）&lt;/h4&gt;

&lt;p&gt;所有的访问API行为，都需要用 TLS 通过安全连接来访问。没有必要搞清或解释什么情况需要 TLS 什么情况不需要 TLS，直接强制任何访问都要通过 TLS。&lt;/p&gt;

&lt;p&gt;理想状态下，通过拒绝所有非 TLS 请求，不响应 http 或80端口的请求以避免任何不安全的数据交换。如果现实情况中无法这样做，可以返回&lt;code&gt;403 Forbidden&lt;/code&gt;响应。&lt;/p&gt;

&lt;p&gt;把非 TLS 的请求重定向(Redirect)至 TLS 连接是不明智的，这种含混/不好的客户端行为不会带来明显好处。依赖于重定向的客户端访问不仅会导致双倍的服务器负载，还会使 TLS 加密失去意义，因为在首次非 TLS 调用时，敏感信息就已经暴露出去了。&lt;/p&gt;

&lt;h4 id=&quot;强制头信息-accept-中提供版本号&quot;&gt;强制头信息 Accept 中提供版本号&lt;/h4&gt;

&lt;p&gt;制定版本并在版本之间平缓过渡对于设计和维护一套API是个巨大的挑战。所以，最好在设计之初就使用一些方法来预防可能会遇到的问题。&lt;/p&gt;

&lt;p&gt;为了避免API的变动导致用户使用中产生意外结果或调用失败，最好强制要求所有访问都需要指定版本号。请避免提供默认版本号，一旦提供，日后想要修改它会相当困难。&lt;/p&gt;

&lt;p&gt;最适合放置版本号的位置是头信息(HTTP Headers)，在 &lt;code&gt;Accept&lt;/code&gt; 段中使用自定义类型(content type)与其他元数据(metadata)一起提交。例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept: application/vnd.heroku+json; version=3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;支持etag缓存&quot;&gt;支持Etag缓存&lt;/h4&gt;

&lt;p&gt;在所有返回的响应中包含&lt;code&gt;ETag&lt;/code&gt;头信息，用来标识资源的版本。这让用户对资源进行缓存处理成为可能，在后续的访问请求中把&lt;code&gt;If-None-Match&lt;/code&gt;头信息设置为之前得到的&lt;code&gt;ETag&lt;/code&gt;值，就可以侦测到已缓存的资源是否需要更新。&lt;/p&gt;

&lt;h4 id=&quot;为内省而提供-request-id&quot;&gt;为内省而提供 Request-Id&lt;/h4&gt;

&lt;p&gt;为每一个请求响应包含一个&lt;code&gt;Request-Id&lt;/code&gt;字段，并使用UUID作为该值。通过在客户端、服务器或任何支持服务上记录该值，它能主我们提供一种机制来跟踪、诊断和调试请求。&lt;/p&gt;

&lt;h4 id=&quot;通过请求中的范围range拆分大的响应&quot;&gt;通过请求中的范围（Range）拆分大的响应&lt;/h4&gt;

&lt;p&gt;一个大的响应应该通过多个请求使用&lt;code&gt;Range&lt;/code&gt;头信息来拆分，并指定如何取得。详细的请求和响应的头信息（header），状态码(status code)，范围(limit)，排序(ordering)和迭代(iteration)等，参考&lt;a href=&quot;https://devcenter.heroku.com/articles/platform-api-reference#ranges&quot;&gt;Heroku Platform API discussion of Ranges&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;###请求（Requests）&lt;/p&gt;

&lt;h4 id=&quot;返回合适的状态码&quot;&gt;返回合适的状态码&lt;/h4&gt;

&lt;p&gt;为每一次的响应返回合适的HTTP状态码。 好的响应应该使用如下的状态码:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;200&lt;/code&gt;: &lt;code&gt;GET&lt;/code&gt;请求成功，及&lt;code&gt;DELETE&lt;/code&gt;或&lt;code&gt;PATCH&lt;/code&gt;同步请求完成，或者&lt;code&gt;PUT&lt;/code&gt;同步更新一个已存在的资源&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;201&lt;/code&gt;: &lt;code&gt;POST&lt;/code&gt; 同步请求完成，或者&lt;code&gt;PUT&lt;/code&gt;同步创建一个新的资源&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;202&lt;/code&gt;: &lt;code&gt;POST&lt;/code&gt;，&lt;code&gt;PUT&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，或&lt;code&gt;PATCH&lt;/code&gt;请求接收，将被异步处理&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;206&lt;/code&gt;: &lt;code&gt;GET&lt;/code&gt; 请求成功，但是只返回一部分，参考：&lt;a href=&quot;#按范围分页&quot;&gt;上文中范围分页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用身份认证（authentication）和授权（authorization）错误码时需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;401 Unauthorized&lt;/code&gt;: 用户未认证，请求失败&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;403 Forbidden&lt;/code&gt;: 用户无权限访问该资源，请求失败&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当用户请求错误时，提供合适的状态码可以提供额外的信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;422 Unprocessable Entity&lt;/code&gt;: 请求被服务器正确解析，但是包含无效字段&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;429 Too Many Requests&lt;/code&gt;: 因为访问频繁，你已经被限制访问，稍后重试&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;500 Internal Server Error&lt;/code&gt;: 服务器错误，确认状态并报告问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于用户错误和服务器错误情况状态码，参考：  &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;HTTP response code spec&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;提供全部可用的资源&quot;&gt;提供全部可用的资源&lt;/h4&gt;

&lt;p&gt;提供全部可显现的资源 (例如： 这个对象的所有属性) ，当响应码为200或是201时返回所有可用资源，包含 &lt;code&gt;PUT&lt;/code&gt;/&lt;code&gt;PATCH&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt;
请求，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;$ curl -X DELETE \
  https://service.com/apps/1f9b/domains/0fd4

HTTP/1.1 200 OK
Content-Type: application/json;charset=utf-8
...
{
  &quot;created_at&quot;: &quot;2012-01-01T12:00:00Z&quot;,
  &quot;hostname&quot;: &quot;subdomain.example.com&quot;,
  &quot;id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,
  &quot;updated_at&quot;: &quot;2012-01-01T12:00:00Z&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当请求状态码为202时，不返回所有可用资源，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -X DELETE \
  https://service.com/apps/1f9b/dynos/05bd

HTTP/1.1 202 Accepted
Content-Type: application/json;charset=utf-8
...
{}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;在请求的body体使用json格式数据&quot;&gt;在请求的body体使用JSON格式数据&lt;/h4&gt;

&lt;p&gt;在 &lt;code&gt;PUT&lt;/code&gt;/&lt;code&gt;PATCH&lt;/code&gt;/&lt;code&gt;POST&lt;/code&gt; 请求的正文（request bodies）中使用JSON格式数据，而不是使用 form 表单形式的数据。这与我们使用JSON格式返回请求相对应，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -X POST https://service.com/apps \
    -H &quot;Content-Type: application/json&quot; \
    -d '{&quot;name&quot;: &quot;demoapp&quot;}'

{
  &quot;id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,
  &quot;name&quot;: &quot;demoapp&quot;,
  &quot;owner&quot;: {
    &quot;email&quot;: &quot;username@example.com&quot;,
    &quot;id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;
  },
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;使用统一的资源路径格式&quot;&gt;使用统一的资源路径格式&lt;/h4&gt;

&lt;h5 id=&quot;资源名resource-names&quot;&gt;资源名（Resource names）&lt;/h5&gt;

&lt;p&gt;使用复数形式为资源命名，除非这个资源在系统中是单例的 (例如，在大多数系统中，给定的用户帐户只有一个)。 这种方式保持了特定资源的统一性。&lt;/p&gt;

&lt;h5 id=&quot;行为actions&quot;&gt;行为（Actions）&lt;/h5&gt;

&lt;p&gt;好的末尾不需要为资源指定特殊的行为，但在特殊情况下，为某些资源指定行为却是必要的。为了描述清楚，在行为前加上一个标准的&lt;code&gt;actions&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/resources/:resource/actions/:action
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/runs/{run_id}/actions/stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;路径和属性要小写&quot;&gt;路径和属性要小写&lt;/h4&gt;

&lt;p&gt;为了和域名命名规则保持一致，使用小写字母并用&lt;code&gt;-&lt;/code&gt;分割路径名字，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service-api.com/users
service-api.com/app-setups
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性也使用小写字母，但是属性名要用下划线&lt;code&gt;_&lt;/code&gt;分割，以便在Javascript中省略引号。 例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;service_class: &quot;first&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;支持方便的无id间接引用&quot;&gt;支持方便的无id间接引用&lt;/h4&gt;

&lt;p&gt;在某些情况下，让用户提供ID去定位资源是不方便的。例如，一个用户想取得他在Heroku平台app信息，但是这个app的唯一标识是UUID。这种情况下，你应该支持接口通过名字和ID都能访问，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://service.com/apps/{app_id_or_name}
$ curl https://service.com/apps/97addcf0-c182
$ curl https://service.com/apps/www-prod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要只接受使用名字而放弃了使用id。&lt;/p&gt;

&lt;h4 id=&quot;最小化路径嵌套&quot;&gt;最小化路径嵌套&lt;/h4&gt;

&lt;p&gt;在一些有父路径/子路径嵌套关系的资源数据模块中，路径可能有非常深的嵌套关系，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/orgs/{org_id}/apps/{app_id}/dynos/{dyno_id}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐在根(root)路径下指定资源来限制路径的嵌套深度。使用嵌套指定范围的资源。在上述例子中，dyno属于app，app属于org可以表示为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/orgs/{org_id}
/orgs/{org_id}/apps
/apps/{app_id}
/apps/{app_id}/dynos
/dynos/{dyno_id}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;响应responses&quot;&gt;响应（Responses）&lt;/h3&gt;

&lt;h4 id=&quot;提供资源的uuid&quot;&gt;提供资源的(UU)ID&lt;/h4&gt;

&lt;p&gt;在默认情况给每一个资源一个&lt;code&gt;id&lt;/code&gt;属性。除非有更好的理由，否则请使用UUID。不要使用那种在服务器上或是资源中不是全局唯一的标识，尤其是自动增长的id。&lt;/p&gt;

&lt;p&gt;生成小写的UUID格式 &lt;code&gt;8-4-4-4-12&lt;/code&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;提供标准的时间戳&quot;&gt;提供标准的时间戳&lt;/h4&gt;

&lt;p&gt;为资源提供默认的创建时间 &lt;code&gt;created_at&lt;/code&gt; 和更新时间 &lt;code&gt;updated_at&lt;/code&gt;，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  ...
  &quot;created_at&quot;: &quot;2012-01-01T12:00:00Z&quot;,
  &quot;updated_at&quot;: &quot;2012-01-01T13:00:00Z&quot;,
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些资源不需要使用时间戳那么就忽略这两个字段。&lt;/p&gt;

&lt;h4 id=&quot;使用utc世界标准时间时间用iso8601进行格式化&quot;&gt;使用UTC（世界标准时间）时间，用ISO8601进行格式化&lt;/h4&gt;

&lt;p&gt;在接收和返回时都只使用UTC格式。ISO8601格式的数据，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;finished_at&quot;: &quot;2012-01-01T12:00:00Z&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;嵌套外键关系&quot;&gt;嵌套外键关系&lt;/h4&gt;

&lt;p&gt;使用嵌套对象序列化外键关联，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;service-production&quot;,
  &quot;owner&quot;: {
    &quot;id&quot;: &quot;5d8201b0...&quot;
  },
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不是像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;service-production&quot;,
  &quot;owner_id&quot;: &quot;5d8201b0...&quot;,
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式尽可能的把相关联的资源信息内联在一起，而不用改变资源的结构，或者引入更多的字段，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;service-production&quot;,
  &quot;owner&quot;: {
    &quot;id&quot;: &quot;5d8201b0...&quot;,
    &quot;name&quot;: &quot;Alice&quot;,
    &quot;email&quot;: &quot;alice@heroku.com&quot;
  },
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;生成结构化的错误&quot;&gt;生成结构化的错误&lt;/h4&gt;

&lt;p&gt;响应错误的时，生成统一的、结构化的错误信息。包含一个机器可读的错误 &lt;code&gt;id&lt;/code&gt;，一个人类能识别的错误信息（&lt;code&gt;message&lt;/code&gt;），根据情况可以添加一个&lt;code&gt;url&lt;/code&gt;来告诉客户端关于这个错误的更多信息以及如何去解决它，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 429 Too Many Requests
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;id&quot;:      &quot;rate_limit&quot;,
  &quot;message&quot;: &quot;Account reached its API rate limit.&quot;,
  &quot;url&quot;:     &quot;https://docs.service.com/rate-limits&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文档化客户端可能遇到的错误信息格式，以及这些可能的错误信息&lt;code&gt;id&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;显示频率限制状态&quot;&gt;显示频率限制状态&lt;/h4&gt;

&lt;p&gt;客户端的访问速度限制可以维护服务器的良好状态，保证为其他客户端请求提供高性的服务。你可以使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Token_bucket&quot;&gt;token bucket algorithm&lt;/a&gt;技术量化请求限制。&lt;/p&gt;

&lt;p&gt;为每一个带有&lt;code&gt;RateLimit-Remaining&lt;/code&gt;响应头的请求，返回预留的请求tokens。&lt;/p&gt;

&lt;h4 id=&quot;保证响应json最小化&quot;&gt;保证响应JSON最小化&lt;/h4&gt;

&lt;p&gt;请求中多余的空格会增加响应大小，而且现在很多的HTTP客户端都会自己输出可读格式（”prettify”）的JSON。所以最好保证响应JSON最小化，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{&quot;beta&quot;:false,&quot;email&quot;:&quot;alice@heroku.com&quot;,&quot;id&quot;:&quot;01234567-89ab-cdef-0123-456789abcdef&quot;,&quot;last_login&quot;:&quot;2012-01-01T12:00:00Z&quot;,&quot;created_at&quot;:&quot;2012-01-01T12:00:00Z&quot;,&quot;updated_at&quot;:&quot;2012-01-01T12:00:00Z&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而不是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;beta&quot;: false,
  &quot;email&quot;: &quot;alice@heroku.com&quot;,
  &quot;id&quot;: &quot;01234567-89ab-cdef-0123-456789abcdef&quot;,
  &quot;last_login&quot;: &quot;2012-01-01T12:00:00Z&quot;,
  &quot;created_at&quot;: &quot;2012-01-01T12:00:00Z&quot;,
  &quot;updated_at&quot;: &quot;2012-01-01T12:00:00Z&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以提供可选的方式为客户端提供更详细可读的响应，使用查询参数（例如：&lt;code&gt;?pretty=true&lt;/code&gt;）或者通过&lt;code&gt;Accept&lt;/code&gt;头信息参数（例如：&lt;code&gt;Accept: application/vnd.heroku+json; version=3; indent=4;&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;###工件（Artifacts）&lt;/p&gt;

&lt;h4 id=&quot;提供机器可读的json模式&quot;&gt;提供机器可读的JSON模式&lt;/h4&gt;

&lt;p&gt;提供一个机器可读的模式来恰当的表现你的API。使用
&lt;a href=&quot;https://github.com/interagent/prmd&quot;&gt;prmd&lt;/a&gt;管理你的模式，并且确保用&lt;code&gt;prmd verify&lt;/code&gt;验证是有效的。&lt;/p&gt;

&lt;h4 id=&quot;提供人类可读的文档&quot;&gt;提供人类可读的文档&lt;/h4&gt;

&lt;p&gt;提供人类可读的文档让客户端开发人员可以理解你的API。&lt;/p&gt;

&lt;p&gt;如果你用prmd创建了一个概要并且按上述要求描述，你可以为所有节点很容易的使用&lt;code&gt;prmd doc&lt;/code&gt;生成Markdown文档。&lt;/p&gt;

&lt;p&gt;除了节点信息，提供一个API概述信息:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证授权，包含如何取得和如何使用token。&lt;/li&gt;
  &lt;li&gt;API稳定及版本管理，包含如何选择所需要的版本。&lt;/li&gt;
  &lt;li&gt;一般情况下的请求和响应的头信息。&lt;/li&gt;
  &lt;li&gt;错误的序列化格式。&lt;/li&gt;
  &lt;li&gt;不同编程语言客户端使用API的例子。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;提供可执行的例子&quot;&gt;提供可执行的例子&lt;/h4&gt;

&lt;p&gt;提供可执行的示例让用户可以直接在终端里面看到API的调用情况，最大程度的让这些示例可以简单的使用，以减少用户尝试使用API的工作量。例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export TOKEN=... # acquire from dashboard
$ curl -is https://$TOKEN@service.com/users
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用&lt;a href=&quot;https://github.com/interagent/prmd&quot;&gt;prmd&lt;/a&gt;生成Markdown文档，每个节点都会自动获取一些示例。&lt;/p&gt;

&lt;h4 id=&quot;描述稳定性&quot;&gt;描述稳定性&lt;/h4&gt;

&lt;p&gt;描述您的API的稳定性或是它在各种各样节点环境中的完备性和稳定性，例如：加上 原型版（prototype）/开发版（development）/产品版（production）等标记。&lt;/p&gt;

&lt;p&gt;更多关于可能的稳定性和改变管理的方式，查看 &lt;a href=&quot;https://devcenter.heroku.com/articles/api-compatibility-policy&quot;&gt;Heroku API compatibility policy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一旦你的API宣布产品正式版本及稳定版本时，不要在当前API版本中做一些不兼容的改变。如果你需要，请创建一个新的版本的API。&lt;/p&gt;
</description>
				<pubDate>Fri, 10 Apr 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/04/10/HTTP_API</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/04/10/HTTP_API</guid>
			</item>

			<item>
				<title>HTML编码规范</title>
				<description>&lt;h2 id=&quot;1-前言&quot;&gt;1 前言&lt;/h2&gt;

&lt;p&gt;HTML作为描述网页结构的超文本标记语言。本文档的目标是使HTML代码风格保持一致，容易被理解和被维护。&lt;/p&gt;

&lt;h2 id=&quot;2-代码风格&quot;&gt;2 代码风格&lt;/h2&gt;

&lt;h3 id=&quot;21-缩进与换行&quot;&gt;2.1 缩进与换行&lt;/h3&gt;

&lt;h4 id=&quot;强制-使用--个空格做为一个缩进层级不允许使用--个空格-或--字符&quot;&gt;[强制] 使用 &lt;code&gt;4&lt;/code&gt; 个空格做为一个缩进层级，不允许使用 &lt;code&gt;2&lt;/code&gt; 个空格 或 &lt;code&gt;tab&lt;/code&gt; 字符。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-每行不得超过--个字符&quot;&gt;[建议] 每行不得超过 &lt;code&gt;120&lt;/code&gt; 个字符。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;过长的代码不容易阅读与维护。但是考虑到 HTML 的特殊性，不做硬性要求。&lt;/p&gt;

&lt;h3 id=&quot;22-命名&quot;&gt;2.2 命名&lt;/h3&gt;

&lt;h4 id=&quot;强制--必须单词全字母小写单词间以--分隔&quot;&gt;[强制] &lt;code&gt;class&lt;/code&gt; 必须单词全字母小写，单词间以 &lt;code&gt;-&lt;/code&gt; 分隔。&lt;/h4&gt;

&lt;h4 id=&quot;强制--必须代表相应模块或部件的内容或功能不得以样式信息进行命名&quot;&gt;[强制] &lt;code&gt;class&lt;/code&gt; 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;div class=&quot;sidebar&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;div class=&quot;left&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-元素--必须保证页面唯一&quot;&gt;[强制] 元素 &lt;code&gt;id&lt;/code&gt; 必须保证页面唯一。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;同一个页面中，不同的元素包含相同的 id，不符合 id 的属性含义。并且使用 document.getElementById 时可能导致难以追查的问题。&lt;/p&gt;

&lt;h4 id=&quot;建议--建议单词全字母小写单词间以--分隔同项目必须保持风格一致&quot;&gt;[建议] &lt;code&gt;id&lt;/code&gt; 建议单词全字母小写，单词间以 &lt;code&gt;-&lt;/code&gt; 分隔。同项目必须保持风格一致。&lt;/h4&gt;

&lt;h4 id=&quot;建议--命名在避免冲突并描述清楚的前提下尽可能短&quot;&gt;[建议] &lt;code&gt;id&lt;/code&gt;、&lt;code&gt;class&lt;/code&gt; 命名，在避免冲突并描述清楚的前提下尽可能短。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;div id=&quot;nav&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- bad --&amp;gt;
&amp;lt;div id=&quot;navigation&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;!-- good --&amp;gt;
&amp;lt;p class=&quot;comment&quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;!-- bad --&amp;gt;
&amp;lt;p class=&quot;com&quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;!-- good --&amp;gt;
&amp;lt;span class=&quot;author&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;!-- bad --&amp;gt;
&amp;lt;span class=&quot;red&quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-禁止为了-创建无样式信息的-&quot;&gt;[强制] 禁止为了 &lt;code&gt;hook 脚本&lt;/code&gt;，创建无样式信息的 &lt;code&gt;class&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;不允许 class 只用于让 JavaScript 选择某些元素，class 应该具有明确的语义和样式。否则容易导致 css class 泛滥。&lt;/p&gt;

&lt;p&gt;使用 id、属性选择作为 hook 是更好的方式。&lt;/p&gt;

&lt;h4 id=&quot;强制-同一页面应避免使用相同的--与-&quot;&gt;[强制] 同一页面，应避免使用相同的 &lt;code&gt;name&lt;/code&gt; 与 &lt;code&gt;id&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;IE 浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心。&lt;/p&gt;

&lt;p&gt;一个比较好的实践是，为 id 和 name 使用不同的命名法。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
&amp;lt;input name=&quot;foo&quot;&amp;gt;
&amp;lt;div id=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
// IE6 将显示 INPUT
alert(document.getElementById('foo').tagName);
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;23-标签&quot;&gt;2.3 标签&lt;/h3&gt;

&lt;h4 id=&quot;强制-标签名必须使用小写字母&quot;&gt;[强制] 标签名必须使用小写字母。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;p&amp;gt;Hello StyleGuide!&amp;lt;/p&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;P&amp;gt;Hello StyleGuide!&amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-对于无需自闭合的标签不允许自闭合&quot;&gt;[强制] 对于无需自闭合的标签，不允许自闭合。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;常见无需自闭合标签有input、br、img、hr等。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;input type=&quot;text&quot; name=&quot;title&quot;&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;input type=&quot;text&quot; name=&quot;title&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-对--中规定允许省略的闭合标签不允许省略闭合标签&quot;&gt;[强制] 对 &lt;code&gt;HTML5&lt;/code&gt; 中规定允许省略的闭合标签，不允许省略闭合标签。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;first
    &amp;lt;li&amp;gt;second
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-标签使用必须符合标签嵌套规则&quot;&gt;[强制] 标签使用必须符合标签嵌套规则。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;比如 div 不得置于 p 中，tbody 必须置于 table 中。&lt;/p&gt;

&lt;p&gt;详细的标签嵌套规则参见&lt;a href=&quot;http://www.cs.tut.fi/~jkorpela/html5.dtd&quot;&gt;HTML DTD&lt;/a&gt;中的 &lt;code&gt;Elements&lt;/code&gt; 定义部分。&lt;/p&gt;

&lt;h4 id=&quot;建议--标签的使用应该遵循标签的语义&quot;&gt;[建议] &lt;code&gt;HTML&lt;/code&gt; 标签的使用应该遵循标签的语义。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;下面是常见标签语义&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;p - 段落&lt;/li&gt;
  &lt;li&gt;h1,h2,h3,h4,h5,h6 - 层级标题&lt;/li&gt;
  &lt;li&gt;strong,em - 强调&lt;/li&gt;
  &lt;li&gt;ins - 插入&lt;/li&gt;
  &lt;li&gt;del - 删除&lt;/li&gt;
  &lt;li&gt;abbr - 缩写&lt;/li&gt;
  &lt;li&gt;code - 代码标识&lt;/li&gt;
  &lt;li&gt;cite - 引述来源作品的标题&lt;/li&gt;
  &lt;li&gt;q - 引用&lt;/li&gt;
  &lt;li&gt;blockquote - 一段或长篇引用&lt;/li&gt;
  &lt;li&gt;ul - 无序列表&lt;/li&gt;
  &lt;li&gt;ol - 有序列表&lt;/li&gt;
  &lt;li&gt;dl,dt,dd - 定义列表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;p&amp;gt;Esprima serves as an important &amp;lt;strong&amp;gt;building block&amp;lt;/strong&amp;gt; for some JavaScript language tools.&amp;lt;/p&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;div&amp;gt;Esprima serves as an important &amp;lt;span class=&quot;strong&quot;&amp;gt;building block&amp;lt;/span&amp;gt; for some JavaScript language tools.&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-在--可以实现相同需求的情况下不得使用表格进行布局&quot;&gt;[建议] 在 &lt;code&gt;CSS&lt;/code&gt; 可以实现相同需求的情况下不得使用表格进行布局。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。&lt;/p&gt;

&lt;h4 id=&quot;建议-标签的使用应尽量简洁减少不必要的标签&quot;&gt;[建议] 标签的使用应尽量简洁，减少不必要的标签。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;img class=&quot;avatar&quot; src=&quot;image.png&quot;&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;span class=&quot;avatar&quot;&amp;gt;
    &amp;lt;img src=&quot;image.png&quot;&amp;gt;
&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;24-属性&quot;&gt;2.4 属性&lt;/h3&gt;

&lt;h4 id=&quot;强制-属性名必须使用小写字母&quot;&gt;[强制] 属性名必须使用小写字母。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;table cellspacing=&quot;0&quot;&amp;gt;...&amp;lt;/table&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;table cellSpacing=&quot;0&quot;&amp;gt;...&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-属性值必须用双引号包围&quot;&gt;[强制] 属性值必须用双引号包围。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;不允许使用单引号，不允许不使用引号。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;script src=&quot;esl.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;script src='esl.js'&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=esl.js&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-布尔类型的属性建议不添加属性值&quot;&gt;[建议] 布尔类型的属性，建议不添加属性值。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;input type=&quot;text&quot; disabled&amp;gt;
&amp;lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-自定义属性建议以--为前缀推荐使用-&quot;&gt;[建议] 自定义属性建议以 &lt;code&gt;xxx-&lt;/code&gt; 为前缀，推荐使用 &lt;code&gt;data-&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;使用前缀有助于区分自定义属性和标准定义的属性。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;ol data-ui-type=&quot;Select&quot;&amp;gt;&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3-通用&quot;&gt;3 通用&lt;/h2&gt;

&lt;h3 id=&quot;31-doctype&quot;&gt;3.1 DOCTYPE&lt;/h3&gt;

&lt;h4 id=&quot;强制-使用--的--来启用标准模式建议使用大写的-&quot;&gt;[强制] 使用 &lt;code&gt;HTML5&lt;/code&gt; 的 &lt;code&gt;doctype&lt;/code&gt; 来启用标准模式，建议使用大写的 &lt;code&gt;DOCTYPE&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-启用-ie-edge-模式&quot;&gt;[建议] 启用 IE Edge 模式。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-在--标签上设置正确的-lang-属性&quot;&gt;[建议] 在 &lt;code&gt;html&lt;/code&gt; 标签上设置正确的 lang 属性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;32-编码&quot;&gt;3.2 编码&lt;/h3&gt;

&lt;h4 id=&quot;强制-页面必须使用精简形式明确指定字符编码指定字符编码的--必须是--的第一个直接子元素&quot;&gt;[强制] 页面必须使用精简形式，明确指定字符编码。指定字符编码的 &lt;code&gt;meta&lt;/code&gt; 必须是 &lt;code&gt;head&lt;/code&gt; 的第一个直接子元素。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&quot;http://www.qianduan.net/html5-charset-can-it.html&quot;&gt;HTML5 Charset能用吗&lt;/a&gt; 一文。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        ......
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        ......
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议--文件使用无--的--编码&quot;&gt;[建议] &lt;code&gt;HTML&lt;/code&gt; 文件使用无 &lt;code&gt;BOM&lt;/code&gt; 的 &lt;code&gt;UTF-8&lt;/code&gt; 编码。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。&lt;/p&gt;

&lt;h3 id=&quot;33-css和javascript引入&quot;&gt;3.3 CSS和JavaScript引入&lt;/h3&gt;

&lt;h4 id=&quot;强制-引入--时必须指明-&quot;&gt;[强制] 引入 &lt;code&gt;CSS&lt;/code&gt; 时必须指明 &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;stylesheet&quot; src=&quot;page.css&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-引入--和--时无须指明--属性&quot;&gt;[建议] 引入 &lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;JavaScript&lt;/code&gt; 时无须指明 &lt;code&gt;type&lt;/code&gt; 属性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;text/css&lt;/code&gt; 和 &lt;code&gt;text/javascript&lt;/code&gt; 是 type 的默认值。&lt;/p&gt;

&lt;h4 id=&quot;建议-展现定义放置于外部--中行为定义放置于外部--中&quot;&gt;[建议] 展现定义放置于外部 &lt;code&gt;CSS&lt;/code&gt; 中，行为定义放置于外部 &lt;code&gt;JavaScript&lt;/code&gt; 中。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。&lt;/p&gt;

&lt;h4 id=&quot;建议-在--中引入页面需要的所有--资源&quot;&gt;[建议] 在 &lt;code&gt;head&lt;/code&gt; 中引入页面需要的所有 &lt;code&gt;CSS&lt;/code&gt; 资源。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;在页面渲染的过程中，新的CSS可能导致元素的样式重新计算和绘制，页面闪烁。&lt;/p&gt;

&lt;h4 id=&quot;建议--应当放在页面末尾或采用异步加载&quot;&gt;[建议] &lt;code&gt;JavaScript&lt;/code&gt; 应当放在页面末尾，或采用异步加载。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;将 script 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;body&amp;gt;
    &amp;lt;!-- a lot of elements --&amp;gt;
    &amp;lt;script src=&quot;init-behavior.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-移动环境或只针对现代浏览器设计的-web-应用如果引用外部资源的--协议部分与页面相同建议省略协议前缀&quot;&gt;[建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 &lt;code&gt;URL&lt;/code&gt; 协议部分与页面相同，建议省略协议前缀。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;protocol-relative URL&lt;/code&gt; 引入 CSS，在 &lt;code&gt;IE7/8&lt;/code&gt; 下，会发两次请求。是否使用 &lt;code&gt;protocol-relative URL&lt;/code&gt; 应充分考虑页面针对的环境。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script src=&quot;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;4-head&quot;&gt;4 head&lt;/h2&gt;

&lt;h3 id=&quot;41-title&quot;&gt;4.1 title&lt;/h3&gt;

&lt;h4 id=&quot;强制-页面必须包含--标签声明标题&quot;&gt;[强制] 页面必须包含 &lt;code&gt;title&lt;/code&gt; 标签声明标题。&lt;/h4&gt;

&lt;h4 id=&quot;强制--必须作为--的直接子元素并紧随--声明之后&quot;&gt;[强制] &lt;code&gt;title&lt;/code&gt; 必须作为 &lt;code&gt;head&lt;/code&gt; 的直接子元素，并紧随 &lt;code&gt;charset&lt;/code&gt; 声明之后。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;title 中如果包含 ascii 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;页面标题&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;42-favicon&quot;&gt;4.2 favicon&lt;/h3&gt;

&lt;h4 id=&quot;强制-保证--可访问&quot;&gt;[强制] 保证 &lt;code&gt;favicon&lt;/code&gt; 可访问。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证favicon可访问，避免404，必须遵循以下两种方法之一：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 Web Server 根目录放置 favicon.ico 文件。&lt;/li&gt;
  &lt;li&gt;使用 link 指定 favicon。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;path/to/favicon.ico&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;43-viewport&quot;&gt;4.3 viewport&lt;/h3&gt;

&lt;h4 id=&quot;建议-若页面欲对移动设备友好需指定页面的-&quot;&gt;[建议] 若页面欲对移动设备友好，需指定页面的 &lt;code&gt;viewport&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;viewport meta tag可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。&lt;/p&gt;

&lt;p&gt;比如，在页面宽度小于 980px 时，若需 iOS 设备友好，应当设置 viewport 的 width 值来适应你的页面宽度。同时因为不同移动设备分辨率不同，在设置时，应当使用 device-width 和 device-height 变量。&lt;/p&gt;

&lt;p&gt;另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，可以参见 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html#//apple_ref/doc/uid/TP40006509-SW26&quot;&gt;Safari Web Content Guide的介绍&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-图片&quot;&gt;5 图片&lt;/h2&gt;

&lt;h4 id=&quot;强制-禁止--的--取值为空延迟加载的图片也要增加默认的-&quot;&gt;[强制] 禁止 &lt;code&gt;img&lt;/code&gt; 的 &lt;code&gt;src&lt;/code&gt; 取值为空。延迟加载的图片也要增加默认的 &lt;code&gt;src&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;src 取值为空，会导致部分浏览器重新加载一次当前页面，参考：&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#emptysrc&quot;&gt;https://developer.yahoo.com/performance/rules.html#emptysrc&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;建议-避免为--添加不必要的--属性&quot;&gt;[建议] 避免为 &lt;code&gt;img&lt;/code&gt; 添加不必要的 &lt;code&gt;title&lt;/code&gt; 属性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;多余的 title 影响看图体验，并且增加了页面尺寸。&lt;/p&gt;

&lt;h4 id=&quot;建议-为重要图片添加--属性&quot;&gt;[建议] 为重要图片添加 &lt;code&gt;alt&lt;/code&gt; 属性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;可以提高图片加载失败时的用户体验。&lt;/p&gt;

&lt;h4 id=&quot;建议-添加--和--属性以避免页面抖动&quot;&gt;[建议] 添加 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 属性，以避免页面抖动。&lt;/h4&gt;

&lt;h4 id=&quot;建议-有下载需求的图片采用--标签实现无下载需求的图片采用--背景图实现&quot;&gt;[建议] 有下载需求的图片采用 &lt;code&gt;img&lt;/code&gt; 标签实现，无下载需求的图片采用 &lt;code&gt;CSS&lt;/code&gt; 背景图实现。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。&lt;/li&gt;
  &lt;li&gt;无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 css 背景图实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;6-表单&quot;&gt;6 表单&lt;/h2&gt;

&lt;h3 id=&quot;61-控件标题&quot;&gt;6.1 控件标题&lt;/h3&gt;

&lt;h4 id=&quot;强制-有文本标题的控件必须使用--标签将其与其标题相关联&quot;&gt;[强制] 有文本标题的控件必须使用 &lt;code&gt;label&lt;/code&gt; 标签将其与其标题相关联。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将控件置于 label 内。&lt;/li&gt;
  &lt;li&gt;label 的 for 属性指向控件的 id。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;label&amp;gt;&amp;lt;input type=&quot;checkbox&quot; name=&quot;confirm&quot; value=&quot;on&quot;&amp;gt; 我已确认上述条款&amp;lt;/label&amp;gt;

&amp;lt;label for=&quot;username&quot;&amp;gt;用户名：&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;textbox&quot; name=&quot;username&quot; id=&quot;username&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;62-按钮&quot;&gt;6.2 按钮&lt;/h3&gt;

&lt;h4 id=&quot;强制-使用--元素时必须指明--属性值&quot;&gt;[强制] 使用 &lt;code&gt;button&lt;/code&gt; 元素时必须指明 &lt;code&gt;type&lt;/code&gt; 属性值。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;button 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;button type=&quot;submit&quot;&amp;gt;提交&amp;lt;/button&amp;gt;
&amp;lt;button type=&quot;button&quot;&amp;gt;取消&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-尽量不要使用按钮类元素的--属性&quot;&gt;[建议] 尽量不要使用按钮类元素的 &lt;code&gt;name&lt;/code&gt; 属性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;由于浏览器兼容性问题，使用按钮的 name 属性会带来许多难以发现的问题。具体情况可参考&lt;a href=&quot;http://w3help.org/zh-cn/causes/CM2001&quot;&gt;此文&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;63-可访问性-a11y&quot;&gt;6.3 可访问性 (A11Y)&lt;/h3&gt;

&lt;h4 id=&quot;建议-负责主要功能的按钮在--中的顺序应靠前&quot;&gt;[建议] 负责主要功能的按钮在 &lt;code&gt;DOM&lt;/code&gt; 中的顺序应靠前。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;负责主要功能的按钮应相对靠前，以提高可访问性。如果在 CSS 中指定了 &lt;code&gt;float: right&lt;/code&gt; 则可能导致视觉上主按钮在前，而 DOM 中主按钮靠后的情况。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;style&amp;gt;
.buttons .button-group {
    float: right;
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;buttons&quot;&amp;gt;
    &amp;lt;div class=&quot;button-group&quot;&amp;gt;
        &amp;lt;button type=&quot;submit&quot;&amp;gt;提交&amp;lt;/button&amp;gt;
        &amp;lt;button type=&quot;button&quot;&amp;gt;取消&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;style&amp;gt;
.buttons button {
    float: right;
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;buttons&quot;&amp;gt;
    &amp;lt;button type=&quot;button&quot;&amp;gt;取消&amp;lt;/button&amp;gt;
    &amp;lt;button type=&quot;submit&quot;&amp;gt;提交&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-当使用--进行表单提交时如果条件允许应使原生提交功能正常工作&quot;&gt;[建议] 当使用 &lt;code&gt;JavaScript&lt;/code&gt; 进行表单提交时，如果条件允许，应使原生提交功能正常工作。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;当浏览器 JS 运行错误或关闭 JS 时，提交功能将无法工作。如果正确指定了 form 元素的 action 属性和表单控件的 name 属性时，提交仍可继续进行。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;form action=&quot;/login&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input name=&quot;username&quot; type=&quot;text&quot; placeholder=&quot;用户名&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-在针对移动设备开发的页面时根据内容类型指定输入框的--属性&quot;&gt;[建议] 在针对移动设备开发的页面时，根据内容类型指定输入框的 &lt;code&gt;type&lt;/code&gt; 属性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;根据内容类型指定输入框类型，能获得能友好的输入体验。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;input type=&quot;date&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;7-多媒体&quot;&gt;7 多媒体&lt;/h2&gt;

&lt;h4 id=&quot;建议-当在现代浏览器中使用--以及--标签来播放音频视频时应当注意格式&quot;&gt;[建议] 当在现代浏览器中使用 &lt;code&gt;audio&lt;/code&gt; 以及 &lt;code&gt;video&lt;/code&gt; 标签来播放音频、视频时，应当注意格式。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;音频应尽可能覆盖到如下格式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MP3&lt;/li&gt;
  &lt;li&gt;WAV&lt;/li&gt;
  &lt;li&gt;Ogg&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视频应尽可能覆盖到如下格式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MP4&lt;/li&gt;
  &lt;li&gt;WebM&lt;/li&gt;
  &lt;li&gt;Ogg&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;建议-在支持--的浏览器中优先使用--和--标签来定义音视频元素&quot;&gt;[建议] 在支持 &lt;code&gt;HTML5&lt;/code&gt; 的浏览器中优先使用 &lt;code&gt;audio&lt;/code&gt; 和 &lt;code&gt;video&lt;/code&gt; 标签来定义音视频元素。&lt;/h4&gt;

&lt;h4 id=&quot;建议-使用退化到插件的方式来对多浏览器进行支持&quot;&gt;[建议] 使用退化到插件的方式来对多浏览器进行支持。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;audio controls&amp;gt;
    &amp;lt;source src=&quot;audio.mp3&quot; type=&quot;audio/mpeg&quot;&amp;gt;
    &amp;lt;source src=&quot;audio.ogg&quot; type=&quot;audio/ogg&quot;&amp;gt;
    &amp;lt;object width=&quot;100&quot; height=&quot;50&quot; data=&quot;audio.mp3&quot;&amp;gt;
        &amp;lt;embed width=&quot;100&quot; height=&quot;50&quot; src=&quot;audio.swf&quot;&amp;gt;
    &amp;lt;/object&amp;gt;
&amp;lt;/audio&amp;gt;

&amp;lt;video width=&quot;100&quot; height=&quot;50&quot; controls&amp;gt;
    &amp;lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot;&amp;gt;
    &amp;lt;source src=&quot;video.ogg&quot; type=&quot;video/ogg&quot;&amp;gt;
    &amp;lt;object width=&quot;100&quot; height=&quot;50&quot; data=&quot;video.mp4&quot;&amp;gt;
        &amp;lt;embed width=&quot;100&quot; height=&quot;50&quot; src=&quot;video.swf&quot;&amp;gt;
    &amp;lt;/object&amp;gt;
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-只在必要的时候开启音视频的自动播放&quot;&gt;[建议] 只在必要的时候开启音视频的自动播放。&lt;/h4&gt;

&lt;h4 id=&quot;建议-在--标签内部提供指示浏览器不支持该标签的说明&quot;&gt;[建议] 在 &lt;code&gt;object&lt;/code&gt; 标签内部提供指示浏览器不支持该标签的说明。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;object width=&quot;100&quot; height=&quot;50&quot; data=&quot;something.swf&quot;&amp;gt;DO NOT SUPPORT THIS TAG&amp;lt;/object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;8-模板中的-html&quot;&gt;8 模板中的 HTML&lt;/h2&gt;

&lt;h4 id=&quot;建议-模板代码的缩进优先保证--代码的缩进规则&quot;&gt;[建议] 模板代码的缩进优先保证 &lt;code&gt;HTML&lt;/code&gt; 代码的缩进规则。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
{if $display == true}
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
    {foreach $item_list as $item}
        &amp;lt;li&amp;gt;{$item.name}&amp;lt;li&amp;gt;
    {/foreach}
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{/if}

&amp;lt;!-- bad --&amp;gt;
{if $display == true}
    &amp;lt;div&amp;gt;
        &amp;lt;ul&amp;gt;
    {foreach $item_list as $item}
        &amp;lt;li&amp;gt;{$item.name}&amp;lt;li&amp;gt;
    {/foreach}
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
{/if}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-模板代码应以保证--单个标签语法的正确性为基本原则&quot;&gt;[建议] 模板代码应以保证 &lt;code&gt;HTML&lt;/code&gt; 单个标签语法的正确性为基本原则。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;li class=&quot;{if $item.type_id == $current_type}focus{/if}&quot;&amp;gt;{ $item.type_name }&amp;lt;/li&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;li {if $item.type_id == $current_type} class=&quot;focus&quot;{/if}&amp;gt;{ $item.type_name }&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-在循环处理模板数据构造表格时若要求每行输出固定的个数建议先将数据分组之后再循环输出&quot;&gt;[建议] 在循环处理模板数据构造表格时，若要求每行输出固定的个数，建议先将数据分组，之后再循环输出。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- good --&amp;gt;
&amp;lt;table&amp;gt;
    {foreach $item_list as $item_group}
    &amp;lt;tr&amp;gt;
        {foreach $item_group as $item}
        &amp;lt;td&amp;gt;{ $item.name }&amp;lt;/td&amp;gt;
        {/foreach}
    &amp;lt;tr&amp;gt;
    {/foreach}
&amp;lt;/table&amp;gt;

&amp;lt;!-- bad --&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
    {foreach $item_list as $item}
    &amp;lt;td&amp;gt;{ $item.name }&amp;lt;/td&amp;gt;
        {if $item@iteration is div by 5}
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        {/if}
    {/foreach}
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
				<pubDate>Thu, 09 Apr 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/04/09/html_guid</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/04/09/html_guid</guid>
			</item>

			<item>
				<title>Less规范</title>
				<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;该文档主要的设计目标是提高 Less 文档的团队一致性与可维护性。&lt;/p&gt;

&lt;p&gt;Less 代码的基本规范和原则与 &lt;a href=&quot;../css_guide&quot;&gt;CSS 编码规范&lt;/a&gt; 保持一致。&lt;/p&gt;

&lt;h3 id=&quot;要求&quot;&gt;要求&lt;/h3&gt;

&lt;p&gt;在本文档中，使用的关键字会以中文+括号包含的关键字英文表示：必须（MUST）。关键字”MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;编码&quot;&gt;编码&lt;/h2&gt;

&lt;p&gt;使用UTF-8编码。&lt;em&gt;不得&lt;/em&gt;（MUST NOT）包含BOM信息。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;代码组织&quot;&gt;代码组织&lt;/h2&gt;

&lt;p&gt;代码&lt;em&gt;必须&lt;/em&gt;（MUST）按如下形式按顺序组织：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;@import&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;变量声明&lt;/li&gt;
  &lt;li&gt;样式声明&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// good
@import &quot;est/all.less&quot;;

@default-text-color: #333;

.page {
    width: 960px;
    margin: 0 auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-语句&quot;&gt;&lt;code&gt;@import&lt;/code&gt; 语句&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;@import&lt;/code&gt; 语句引用的文件&lt;em&gt;必须&lt;/em&gt;（MUST）写在一对引号内，&lt;code&gt;.less&lt;/code&gt; 后缀&lt;em&gt;不得&lt;/em&gt;（MUST NOT）省略（与引入 CSS 文件时的路径格式一致）。引号使用 &lt;code&gt;'&lt;/code&gt; 和 &lt;code&gt;&quot;&lt;/code&gt; 均可，但在同一项目内&lt;em&gt;必须&lt;/em&gt;（MUST）统一。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
@import 'est/all';
@import &quot;my/mixins.less&quot;;

// good
@import &quot;est/all.less&quot;;
@import &quot;my/mixins.less&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;空格&quot;&gt;空格&lt;/h2&gt;

&lt;h3 id=&quot;属性变量&quot;&gt;属性、变量&lt;/h3&gt;

&lt;p&gt;选择器和 &lt;code&gt;{&lt;/code&gt; 之间&lt;em&gt;必须&lt;/em&gt;（MUST）保留一个空格。&lt;/p&gt;

&lt;p&gt;属性名后的冒号（&lt;code&gt;:&lt;/code&gt;）与属性值之间&lt;em&gt;必须&lt;/em&gt;（MUST）保留一个空格，冒号前&lt;em&gt;不得&lt;/em&gt;（MUST NOT）保留空格。&lt;/p&gt;

&lt;p&gt;定义变量时冒号（&lt;code&gt;:&lt;/code&gt;）与变量值之间&lt;em&gt;必须&lt;/em&gt;（MUST）保留一个空格，冒号前&lt;em&gt;不得&lt;/em&gt;（MUST NOT）保留空格。&lt;/p&gt;

&lt;p&gt;在用逗号（&lt;code&gt;,&lt;/code&gt;）分隔的列表（Less 函数参数列表、以 &lt;code&gt;,&lt;/code&gt; 分隔的属性值等）中，逗号后&lt;em&gt;必须&lt;/em&gt;（MUST）保留一个空格，逗号前&lt;em&gt;不得&lt;/em&gt;（MUST NOT）保留空格。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
.box{
    @w:50px;
    @h :30px;
    width:@w;
    height :@h;
    color: rgba(255,255,255,.3);
    transition: width 1s,height 3s;
}

// good
.box {
    @w: 50px;
    @h: 30px;
    width: @w;
    height: @h;
    transition: width 1s, height 3s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;运算&quot;&gt;运算&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; / &lt;code&gt;*&lt;/code&gt; / &lt;code&gt;/&lt;/code&gt; 四个运算符两侧&lt;em&gt;必须&lt;/em&gt;（MUST）保留一个空格。&lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; 两侧的操作数&lt;em&gt;必须&lt;/em&gt;（MUST）有相同的单位，如果其中一个是变量，另一个数值&lt;em&gt;必须&lt;/em&gt;（MUST）书写单位。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
@a: 200px;
@b: (@a+100)*2;

// good
@a: 200px;
@b: (@a + 100px) * 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;混入mixin&quot;&gt;混入（Mixin）&lt;/h3&gt;

&lt;p&gt;Mixin 和后面的空格之间&lt;em&gt;不得&lt;/em&gt;（MUST NOT）包含空格。在给 mixin 传递参数时，在参数分隔符（&lt;code&gt;,&lt;/code&gt; / &lt;code&gt;;&lt;/code&gt;）后&lt;em&gt;必须&lt;/em&gt;（MUST）保留一个空格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
.box {
    .size(30px,20px);
    .clearfix ();
}

// good
.box {
    .size(30px, 20px);
    .clearfix();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;选择器&quot;&gt;选择器&lt;/h2&gt;

&lt;p&gt;当多个选择器共享一个声明块时，每个选择器声明&lt;em&gt;必须&lt;/em&gt;（MUST）独占一行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
h1, h2, h3 {
    font-weight: 700;
}

// good
h1,
h2,
h3 {
    font-weight: 700;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Class 命名不得以样式信息进行描述，如 &lt;code&gt;.float-right&lt;/code&gt;、&lt;code&gt;text-red&lt;/code&gt; 等。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;省略与缩写&quot;&gt;省略与缩写&lt;/h2&gt;

&lt;h3 id=&quot;缩写&quot;&gt;缩写&lt;/h3&gt;

&lt;p&gt;多个属性定义可以使用缩写时， &lt;em&gt;尽量&lt;/em&gt;（SHOULD）使用缩写。缩写更清晰字节数更少。常见缩写有 &lt;code&gt;margin&lt;/code&gt;、&lt;code&gt;border&lt;/code&gt;、&lt;code&gt;padding&lt;/code&gt;、&lt;code&gt;font&lt;/code&gt;、&lt;code&gt;list-style&lt;/code&gt; 等。在书写时&lt;em&gt;必须&lt;/em&gt;（MUST）考量缩写展开后是否有不需要覆盖的属性内容被修改，从而带来副作用。&lt;/p&gt;

&lt;h3 id=&quot;数值&quot;&gt;数值&lt;/h3&gt;

&lt;p&gt;对于处于 &lt;code&gt;(0, 1)&lt;/code&gt; 范围内的数值，小数点前的 &lt;code&gt;0&lt;/code&gt; &lt;em&gt;可以&lt;/em&gt;（MAY）省略，同一项目中&lt;em&gt;必须&lt;/em&gt;（MUST）保持一致。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
transition-duration: 0.5s, .7s;

// good
transition-duration: .5s, .7s;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;0-值&quot;&gt;0 值&lt;/h3&gt;

&lt;p&gt;当属性值为 0 时，&lt;em&gt;必须&lt;/em&gt;（MUST）省略可省的单位（长度单位如 &lt;code&gt;px&lt;/code&gt;、&lt;code&gt;em&lt;/code&gt;，不包括时间、角度等如 &lt;code&gt;s&lt;/code&gt;、&lt;code&gt;deg&lt;/code&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
margin-top: 0px;

// good
margin-top: 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;颜色&quot;&gt;颜色&lt;/h3&gt;

&lt;p&gt;颜色定义&lt;em&gt;必须&lt;/em&gt;（MUST）使用 &lt;code&gt;#rrggbb&lt;/code&gt; 格式定义，并在可能时&lt;em&gt;尽量&lt;/em&gt;（SHOULD）缩写为 &lt;code&gt;#rgb&lt;/code&gt; 形式，且避免直接使用颜色名称与 &lt;code&gt;rgb()&lt;/code&gt; 表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
border-color: red;
color: rgb(254, 254, 254);

// good
border-color: #f00;
color: #fefefe;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;私有属性前缀&quot;&gt;私有属性前缀&lt;/h3&gt;

&lt;p&gt;同一属性有不同私有前缀的，&lt;em&gt;尽量&lt;/em&gt;（SHOULD）按前缀长度降序书写，标准形式&lt;em&gt;必须&lt;/em&gt;（MUST）写在最后。且这一组属性以第一条的位置为准，&lt;em&gt;尽量&lt;/em&gt;（SHOULD）按冒号的位置对齐。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// good
.box {
    -webkit-transform: rotate(30deg);
       -moz-transform: rotate(30deg);
        -ms-transform: rotate(30deg);
         -o-transform: rotate(30deg);
            transform: rotate(30deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;可以&lt;/em&gt;（MAY）在无其他更好解决办法时使用 CSS hack，并且&lt;em&gt;尽量&lt;/em&gt;（SHOULD）使用简单的属性名 hack 如 &lt;code&gt;_zoom&lt;/code&gt;、&lt;code&gt;*margin&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;可以&lt;/em&gt;（MAY）但谨慎使用 IE 滤镜。需要注意的是，IE 滤镜中图片的 URL 是以页面路径作为相对目录，而不是 CSS 文件路径。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;嵌套和缩进&quot;&gt;嵌套和缩进&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;必须&lt;/em&gt;（MUST）采用 4 个空格为一次缩进， &lt;em&gt;不得&lt;/em&gt;（MUST NOT）采用 TAB 作为缩进。&lt;/p&gt;

&lt;p&gt;嵌套的声明块前&lt;em&gt;必须&lt;/em&gt;（MUST）增加一次缩进，有多个声明块共享命名空间时&lt;em&gt;尽量&lt;/em&gt;（SHOULD）嵌套书写，避免选择器的重复。&lt;/p&gt;

&lt;p&gt;但是需注意的是，&lt;em&gt;尽量&lt;/em&gt;（SHOULD）仅在必须区分上下文时才引入嵌套关系（在嵌套书写前先考虑如果不能嵌套，会如何书写选择器）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
.main .title {
  font-weight: 700;
}

.main .content {
  line-height: 1.5;
}

.main {
.warning {
  font-weight: 700;
}

  .comment-form {
    #comment:invalid {
      color: red;
    }
  }
}

// good
.main {
    .title {
        font-weight: 700;
    }

    .content {
        line-height: 1.5;
    }

    .warning {
        font-weight: 700;
    }
}

#comment:invalid {
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;Less 的变量值总是以同一作用域下最后一个同名变量为准，务必注意后面的设定会覆盖所有之前的设定。&lt;/p&gt;

&lt;p&gt;变量命名&lt;em&gt;必须&lt;/em&gt;（MUST）采用 &lt;code&gt;@foo-bar&lt;/code&gt; 形式，&lt;em&gt;不得&lt;/em&gt;（MUST NOT）使用 &lt;code&gt;@fooBar&lt;/code&gt; 形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
@sidebarWidth: 200px;
@width:800px;

// good
@sidebar-width: 200px;
@width: 800px;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;

&lt;p&gt;使用继承时，如果在声明块内书写 &lt;code&gt;:extend&lt;/code&gt; 语句，&lt;em&gt;必须&lt;/em&gt;（MUST）写在开头：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
.sub {
    color: red;
    &amp;amp;:extend(.mod all);
}

// good
.sub {
    &amp;amp;:extend(.mod all);
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;混入mixin-1&quot;&gt;混入（Mixin）&lt;/h2&gt;

&lt;p&gt;在定义 mixin 时，如果 mixin 名称不是一个需要使用的 className，&lt;em&gt;必须&lt;/em&gt;（MUST）加上括号，否则即使不被调用也会输出到 CSS 中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
.big-text {
    font-size: 2em;
}

h3 {
    .big-text;
}

// good
.big-text() {
    font-size: 2em;
}

h3 {
    .big-text();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果混入的是本身不输出内容的 mixin，&lt;em&gt;必须&lt;/em&gt;（MUST）在 mixin 后添加括号（即使不传参数），以区分这是否是一个 className（修改以后是否会影响 HTML）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// bad
.box {
    .clearfix;
    .size (20px);
}

// good
.box {
    .clearfix();
    .size(20px);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mixin 的参数分隔符使用 &lt;code&gt;,&lt;/code&gt; 和 &lt;code&gt;;&lt;/code&gt; 均可，但在同一项目中&lt;em&gt;必须&lt;/em&gt;（MUST）保持统一。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;命名空间&quot;&gt;命名空间&lt;/h2&gt;

&lt;p&gt;变量和 mixin 在命名时&lt;em&gt;必须&lt;/em&gt;（MUST）遵循如下原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个项目只能引入一个无命名前缀的基础样式库（如 est）&lt;/li&gt;
  &lt;li&gt;业务代码和其他被引入的样式代码中，变量和 mixin 必须有项目或库的前缀&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;字符串&quot;&gt;字符串&lt;/h2&gt;

&lt;p&gt;在进行字符串转义时，使用 &lt;code&gt;~&quot;&quot;&lt;/code&gt; 表达式与 &lt;code&gt;e()&lt;/code&gt; 函数均可，但在同一项目中&lt;em&gt;必须&lt;/em&gt;（MUST）保持一致。&lt;/p&gt;

&lt;p&gt;字符串两侧的引号&lt;em&gt;必须&lt;/em&gt;（MUST）使用 &lt;code&gt;&quot;&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;js-表达式&quot;&gt;JS 表达式&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;可以&lt;/em&gt;（MAY）使用 JS 表达式（&lt;code&gt;~\`\`&lt;/code&gt;）生成属性值或变量，其中包含的字符串两侧的引号&lt;em&gt;尽量&lt;/em&gt;（SHOULD）使用单引号（&lt;code&gt;'&lt;/code&gt;）。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;p&gt;单行注释&lt;em&gt;尽量&lt;/em&gt;（SHOULD）使用 &lt;code&gt;//&lt;/code&gt; 方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;// Hide everything
* {
    display: none;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Tue, 31 Mar 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/31/less_guide</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/31/less_guide</guid>
			</item>

			<item>
				<title>JavaScript规范</title>
				<description>&lt;h2 id=&quot;内容列表&quot;&gt;&lt;a name=&quot;TOC&quot;&gt;内容列表&lt;/a&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#types&quot;&gt;类型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#objects&quot;&gt;对象&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#arrays&quot;&gt;数组&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#strings&quot;&gt;字符串&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#functions&quot;&gt;函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#properties&quot;&gt;属性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#variables&quot;&gt;变量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conditionals&quot;&gt;条件表达式和等号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#blocks&quot;&gt;块&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#comments&quot;&gt;注释&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#whitespace&quot;&gt;空白&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#commas&quot;&gt;逗号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#semicolons&quot;&gt;分号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#type-coercion&quot;&gt;类型转换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#naming-conventions&quot;&gt;命名约定&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#accessors&quot;&gt;存取器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#constructors&quot;&gt;构造器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#events&quot;&gt;事件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#modules&quot;&gt;模块&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jquery&quot;&gt;jQuery&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类型&quot;&gt;&lt;a name=&quot;types&quot;&gt;类型&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;原始值&lt;/strong&gt;: 相当于传值&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;number&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var foo = 1,
    bar = foo;

bar = 9;

console.log(foo, bar); // =&amp;gt; 1, 9
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;复杂类型&lt;/strong&gt;: 相当于传引用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;object&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;array&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;function&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var foo = [1, 2],
    bar = foo;

bar[0] = 9;

console.log(foo[0], bar[0]); // =&amp;gt; 9, 9
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;对象&quot;&gt;&lt;a name=&quot;objects&quot;&gt;对象&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用字面值创建对象&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var item = new Object();

// good
var item = {};
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要使用保留字 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Reserved_Words&quot;&gt;reserved words&lt;/a&gt; 作为键&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var superman = {
  class: 'superhero',
  default: { clark: 'kent' },
  private: true
};

// good
var superman = {
  klass: 'superhero',
  defaults: { clark: 'kent' },
  hidden: true
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数组&quot;&gt;&lt;a name=&quot;arrays&quot;&gt;数组&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用字面值创建数组&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var items = new Array();

// good
var items = [];
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你不知道数组的长度，使用push&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var someStack = [];


// bad
someStack[someStack.length] = 'abracadabra';

// good
someStack.push('abracadabra');
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你需要拷贝数组时使用slice. &lt;a href=&quot;http://jsperf.com/converting-arguments-to-an-array/7&quot;&gt;jsPerf&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var len = items.length,
    itemsCopy = [],
    i;

// bad
for (i = 0; i &amp;lt; len; i++) {
  itemsCopy[i] = items[i];
}

// good
itemsCopy = items.slice();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用slice将类数组的对象转成数组.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function trigger() {
  var args = Array.prototype.slice.call(arguments);
  ...
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;字符串&quot;&gt;&lt;a name=&quot;strings&quot;&gt;字符串&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对字符串使用单引号 &lt;code&gt;''&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var name = &quot;Bob Parr&quot;;

// good
var name = 'Bob Parr';

// bad
var fullName = &quot;Bob &quot; + this.lastName;

// good
var fullName = 'Bob ' + this.lastName;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;超过80个字符的字符串应该使用字符串连接换行&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注: 如果过度使用，长字符串连接可能会对性能有影响. &lt;a href=&quot;http://jsperf.com/ya-string-concat&quot;&gt;jsPerf&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://github.com/airbnb/javascript/issues/40&quot;&gt;Discussion&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';

// bad
var errorMessage = 'This is a super long error that \
was thrown because of Batman. \
When you stop to think about \
how Batman had anything to do \
with this, you would get nowhere \
fast.';


// good
var errorMessage = 'This is a super long error that ' +
  'was thrown because of Batman.' +
  'When you stop to think about ' +
  'how Batman had anything to do ' +
  'with this, you would get nowhere ' +
  'fast.';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程时使用join而不是字符串连接来构建字符串，特别是IE: &lt;a href=&quot;http://jsperf.com/string-vs-array-concat/2&quot;&gt;jsPerf&lt;/a&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var items,
    messages,
    length, i;

messages = [{
    state: 'success',
    message: 'This one worked.'
},{
    state: 'success',
    message: 'This one worked as well.'
},{
    state: 'error',
    message: 'This one did not work.'
}];

length = messages.length;

// bad
function inbox(messages) {
  items = '&amp;lt;ul&amp;gt;';

  for (i = 0; i &amp;lt; length; i++) {
    items += '&amp;lt;li&amp;gt;' + messages[i].message + '&amp;lt;/li&amp;gt;';
  }

  return items + '&amp;lt;/ul&amp;gt;';
}

// good
function inbox(messages) {
  items = [];

  for (i = 0; i &amp;lt; length; i++) {
    items[i] = messages[i].message;
  }

  return '&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;' + items.join('&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;') + '&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;';
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数&quot;&gt;&lt;a name=&quot;functions&quot;&gt;函数&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数表达式:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 匿名函数表达式
var anonymous = function() {
  return true;
};

// 有名函数表达式
var named = function named() {
  return true;
};

// 立即调用函数表达式
(function() {
  console.log('Welcome to the Internet. Please follow me.');
})();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; ECMA-262定义把&lt;code&gt;块&lt;/code&gt;定义为一组语句，函数声明不是一个语句。&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97&quot;&gt;阅读ECMA-262对这个问题的说明&lt;/a&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
if (currentUser) {
  function test() {
    console.log('Nope.');
  }
}

// good
if (currentUser) {
  var test = function test() {
    console.log('Yup.');
  };
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绝对不要把参数命名为 &lt;code&gt;arguments&lt;/code&gt;, 这将会逾越函数作用域内传过来的 &lt;code&gt;arguments&lt;/code&gt; 对象.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function nope(name, options, arguments) {
  // ...stuff...
}

// good
function yup(name, options, args) {
  // ...stuff...
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;属性&quot;&gt;&lt;a name=&quot;properties&quot;&gt;属性&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当使用变量访问属性时使用中括号.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var luke = {
  jedi: true,
  age: 28
};

function getProp(prop) {
  return luke[prop];
}

var isJedi = getProp('jedi');
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;变量&quot;&gt;&lt;a name=&quot;variables&quot;&gt;变量&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;总是使用 &lt;code&gt;var&lt;/code&gt; 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
superPower = new SuperPower();

// good
var superPower = new SuperPower();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用一个 &lt;code&gt;var&lt;/code&gt; 以及新行声明多个变量，缩进4个空格。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var items = getItems();
var goSportsTeam = true;
var dragonball = 'z';

// good
var items = getItems(),
    goSportsTeam = true,
    dragonball = 'z';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后再声明未赋值的变量，当你想引用之前已赋值变量的时候很有用。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var i, len, dragonball,
    items = getItems(),
    goSportsTeam = true;

// bad
var i, items = getItems(),
    dragonball,
    goSportsTeam = true,
    len;

// good
var items = getItems(),
    goSportsTeam = true,
    dragonball,
    length,
    i;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function() {
  test();
  console.log('doing stuff..');

  //..other stuff..

  var name = getName();

  if (name === 'test') {
    return false;
  }

  return name;
}

// good
function() {
  var name = getName();

  test();
  console.log('doing stuff..');

  //..other stuff..

  if (name === 'test') {
    return false;
  }

  return name;
}

// bad
function() {
  var name = getName();

  if (!arguments.length) {
    return false;
  }

  return true;
}

// good
function() {
  if (!arguments.length) {
    return false;
  }

  var name = getName();

  return true;
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;条件表达式和等号&quot;&gt;&lt;a name=&quot;conditionals&quot;&gt;条件表达式和等号&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;适当使用 &lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt; 以及 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;条件表达式的强制类型转换遵循以下规则：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt; 被计算为 &lt;strong&gt;true&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Undefined&lt;/strong&gt; 被计算为 &lt;strong&gt;false&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Null&lt;/strong&gt; 被计算为 &lt;strong&gt;false&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;布尔值&lt;/strong&gt; 被计算为 &lt;strong&gt;布尔的值&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;数字&lt;/strong&gt; 如果是 &lt;strong&gt;+0, -0, or NaN&lt;/strong&gt; 被计算为 &lt;strong&gt;false&lt;/strong&gt; , 否则为 &lt;strong&gt;true&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;字符串&lt;/strong&gt; 如果是空字符串 &lt;code&gt;''&lt;/code&gt; 则被计算为 &lt;strong&gt;false&lt;/strong&gt;, 否则为 &lt;strong&gt;true&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if ([0]) {
  // true
  // An array is an object, objects evaluate to true
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用快捷方式.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
if (name !== '') {
  // ...stuff...
}

// good
if (name) {
  // ...stuff...
}

// bad
if (collection.length &amp;gt; 0) {
  // ...stuff...
}

// good
if (collection.length) {
  // ...stuff...
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阅读 &lt;a href=&quot;http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108&quot;&gt;Truth Equality and JavaScript&lt;/a&gt; 了解更多&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;块&quot;&gt;&lt;a name=&quot;blocks&quot;&gt;块&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;给所有多行的块使用大括号&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
if (test)
  return false;

// good
if (test) return false;

// good
if (test) {
  return false;
}

// bad
function() { return false; }

// good
function() {
  return false;
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;注释&quot;&gt;&lt;a name=&quot;comments&quot;&gt;注释&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code&gt;/** ... */&lt;/code&gt; 进行多行注释，包括描述，指定类型以及参数值和返回值&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
// make() returns a new element
// based on the passed in tag name
//
// @param &amp;lt;String&amp;gt; tag
// @return &amp;lt;Element&amp;gt; element
function make(tag) {

  // ...stuff...

  return element;
}

// good
/**
 * make() returns a new element
 * based on the passed in tag name
 *
 * @param &amp;lt;String&amp;gt; tag
 * @return &amp;lt;Element&amp;gt; element
 */
function make(tag) {

  // ...stuff...

  return element;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code&gt;//&lt;/code&gt; 进行单行注释，在评论对象的上面进行单行注释，注释前放一个空行.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var active = true;  // is current tab

// good
// is current tab
var active = true;

// bad
function getType() {
  console.log('fetching type...');
  // set the default type to 'no type'
  var type = this._type || 'no type';

  return type;
}

// good
function getType() {
  console.log('fetching type...');

  // set the default type to 'no type'
  var type = this._type || 'no type';

  return type;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你有一个问题需要重新来看一下或如果你建议一个需要被实现的解决方法的话需要在你的注释前面加上 &lt;code&gt;FIXME&lt;/code&gt; 或 &lt;code&gt;TODO&lt;/code&gt; 帮助其他人迅速理解&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Calculator() {

  // FIXME: shouldn't use a global here
  total = 0;

  return this;
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Calculator() {

  // TODO: total should be configurable by an options param
  this.total = 0;

  return this;
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;空白&quot;&gt;&lt;a name=&quot;whitespace&quot;&gt;空白&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将tab设为4个空格&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function() {
∙∙var name;
}

// bad
function() {
∙var name;
}

// good
function() {
∙∙∙∙var name;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大括号前放一个空格&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function test(){
  console.log('test');
}

// good
function test() {
  console.log('test');
}

// bad
dog.set('attr',{
  age: '1 year',
  breed: 'Bernese Mountain Dog'
});

// good
dog.set('attr', {
  age: '1 year',
  breed: 'Bernese Mountain Dog'
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在做长方法链时使用缩进.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
$('#items').find('.selected').highlight().end().find('.open').updateCount();

// good
$('#items')
  .find('.selected')
    .highlight()
    .end()
  .find('.open')
    .updateCount();

// bad
var leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true)
    .attr('width',  (radius + margin) * 2).append('svg:g')
    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')
    .call(tron.led);

// good
var leds = stage.selectAll('.led')
    .data(data)
  .enter().append('svg:svg')
    .class('led', true)
    .attr('width',  (radius + margin) * 2)
  .append('svg:g')
    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')
    .call(tron.led);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;逗号&quot;&gt;&lt;a name=&quot;commas&quot;&gt;逗号&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不要将逗号放前面&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var once
  , upon
  , aTime;

// good
var once,
    upon,
    aTime;

// bad
var hero = {
    firstName: 'Bob'
  , lastName: 'Parr'
  , heroName: 'Mr. Incredible'
  , superPower: 'strength'
};

// good
var hero = {
  firstName: 'Bob',
  lastName: 'Parr',
  heroName: 'Mr. Incredible',
  superPower: 'strength'
};
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要加多余的逗号，这可能会在IE下引起错误，同时如果多一个逗号某些ES3的实现会计算多数组的长度。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var hero = {
  firstName: 'Kevin',
  lastName: 'Flynn',
};

var heroes = [
  'Batman',
  'Superman',
];

// good
var hero = {
  firstName: 'Kevin',
  lastName: 'Flynn'
};

var heroes = [
  'Batman',
  'Superman'
];
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分号&quot;&gt;&lt;a name=&quot;semicolons&quot;&gt;分号&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;语句结束一定要加分号&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
(function() {
  var name = 'Skywalker'
  return name
})()

// good
(function() {
  var name = 'Skywalker';
  return name;
})();

// good
;(function() {
  var name = 'Skywalker';
  return name;
})();
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;类型转换&quot;&gt;&lt;a name=&quot;type-coercion&quot;&gt;类型转换&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在语句的开始执行类型转换.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//  =&amp;gt; this.reviewScore = 9;

// bad
var totalScore = this.reviewScore + '';

// good
var totalScore = '' + this.reviewScore;

// bad
var totalScore = '' + this.reviewScore + ' total score';

// good
var totalScore = this.reviewScore + ' total score';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对数字使用 &lt;code&gt;parseInt&lt;/code&gt; 并且总是带上类型转换的基数.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var inputValue = '4';

// bad
var val = new Number(inputValue);

// bad
var val = +inputValue;

// bad
var val = inputValue &amp;gt;&amp;gt; 0;

// bad
var val = parseInt(inputValue);

// good
var val = Number(inputValue);

// good
var val = parseInt(inputValue, 10);

// good
/**
 * parseInt was the reason my code was slow.
 * Bitshifting the String to coerce it to a
 * Number made it a lot faster.
 */
var val = inputValue &amp;gt;&amp;gt; 0;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;布尔值:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var age = 0;

// bad
var hasAge = new Boolean(age);

// good
var hasAge = Boolean(age);

// good
var hasAge = !!age;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;命名约定&quot;&gt;&lt;a name=&quot;naming-conventions&quot;&gt;命名约定&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;避免单个字符名，让你的变量名有描述意义。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function q() {
  // ...stuff...
}

// good
function query() {
  // ..stuff..
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当命名对象、函数和实例时使用驼峰命名规则&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
var OBJEcttsssss = {};
var this_is_my_object = {};
var this-is-my-object = {};
function c() {};
var u = new user({
  name: 'Bob Parr'
});

// good
var thisIsMyObject = {};
function thisIsMyFunction() {};
var user = new User({
  name: 'Bob Parr'
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当命名构造函数或类时使用驼峰式大写&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function user(options) {
  this.name = options.name;
}

var bad = new user({
  name: 'nope'
});

// good
function User(options) {
  this.name = options.name;
}

var good = new User({
  name: 'yup'
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命名私有属性时前面加个下划线 &lt;code&gt;_&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
this.__firstName__ = 'Panda';
this.firstName_ = 'Panda';

// good
this._firstName = 'Panda';
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当保存对 &lt;code&gt;this&lt;/code&gt; 的引用时使用 &lt;code&gt;_this&lt;/code&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function() {
  var self = this;
  return function() {
    console.log(self);
  };
}

// bad
function() {
  var that = this;
  return function() {
    console.log(that);
  };
}

// good
function() {
  var _this = this;
  return function() {
    console.log(_this);
  };
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;存取器&quot;&gt;&lt;a name=&quot;accessors&quot;&gt;存取器&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;属性的存取器函数不是必需的&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你确实有存取器函数的话使用getVal() 和 setVal(‘hello’)&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
dragon.age();

// good
dragon.getAge();

// bad
dragon.age(25);

// good
dragon.setAge(25);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果属性是布尔值，使用isVal() 或 hasVal()&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
if (!dragon.age()) {
  return false;
}

// good
if (!dragon.hasAge()) {
  return false;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以创建get()和set()函数，但是要保持一致&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Jedi(options) {
  options || (options = {});
  var lightsaber = options.lightsaber || 'blue';
  this.set('lightsaber', lightsaber);
}

Jedi.prototype.set = function(key, val) {
  this[key] = val;
};

Jedi.prototype.get = function(key) {
  return this[key];
};
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;构造器&quot;&gt;&lt;a name=&quot;constructors&quot;&gt;构造器&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Jedi() {
  console.log('new jedi');
}

// bad
Jedi.prototype = {
  fight: function fight() {
    console.log('fighting');
  },

  block: function block() {
    console.log('blocking');
  }
};

// good
Jedi.prototype.fight = function fight() {
  console.log('fighting');
};

Jedi.prototype.block = function block() {
  console.log('blocking');
};
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法可以返回 &lt;code&gt;this&lt;/code&gt; 帮助方法可链。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
Jedi.prototype.jump = function() {
  this.jumping = true;
  return true;
};

Jedi.prototype.setHeight = function(height) {
  this.height = height;
};

var luke = new Jedi();
luke.jump(); // =&amp;gt; true
luke.setHeight(20) // =&amp;gt; undefined

// good
Jedi.prototype.jump = function() {
  this.jumping = true;
  return this;
};

Jedi.prototype.setHeight = function(height) {
  this.height = height;
  return this;
};

var luke = new Jedi();

luke.jump()
  .setHeight(20);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用。&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Jedi(options) {
  options || (options = {});
  this.name = options.name || 'no name';
}

Jedi.prototype.getName = function getName() {
  return this.name;
};

Jedi.prototype.toString = function toString() {
  return 'Jedi - ' + this.getName();
};
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;事件&quot;&gt;&lt;a name=&quot;events&quot;&gt;事件&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// bad
$(this).trigger('listingUpdated', listing.id);

...

$(this).on('listingUpdated', function(e, listingId) {
  // do something with listingId
});
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;更好:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// good
$(this).trigger('listingUpdated', { listingId : listing.id });

...

$(this).on('listingUpdated', function(e, data) {
  // do something with data.listingId
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;模块&quot;&gt;&lt;a name=&quot;modules&quot;&gt;模块&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;模块应该以 &lt;code&gt;!&lt;/code&gt; 开始，这保证了如果一个有问题的模块忘记包含最后的分号在合并后不会出现错误&lt;/li&gt;
  &lt;li&gt;这个文件应该以驼峰命名，并在同名文件夹下，同时导出的时候名字一致&lt;/li&gt;
  &lt;li&gt;加入一个名为noConflict()的方法来设置导出的模块为之前的版本并返回它&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总是在模块顶部声明 &lt;code&gt;'use strict';&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// fancyInput/fancyInput.js

!function(global) {
  'use strict';

  var previousFancyInput = global.FancyInput;

  function FancyInput(options) {
    this.options = options || {};
  }

  FancyInput.noConflict = function noConflict() {
    global.FancyInput = previousFancyInput;
    return FancyInput;
  };

  global.FancyInput = FancyInput;
}(this);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jquery&quot;&gt;&lt;a name=&quot;jquery&quot;&gt;jQuery&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;缓存jQuery查询&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
function setSidebar() {
  $('.sidebar').hide();

  // ...stuff...

  $('.sidebar').css({
    'background-color': 'pink'
  });
}

// good
function setSidebar() {
  var $sidebar = $('.sidebar');
  $sidebar.hide();

  // ...stuff...

  $sidebar.css({
    'background-color': 'pink'
  });
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;对DOM查询使用级联的 &lt;code&gt;$('.sidebar ul')&lt;/code&gt; 或 &lt;code&gt;$('.sidebar ul')&lt;/code&gt;，&lt;a href=&quot;http://jsperf.com/jquery-find-vs-context-sel/16&quot;&gt;jsPerf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对有作用域的jQuery对象查询使用 &lt;code&gt;find&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// bad
$('.sidebar', 'ul').hide();

// bad
$('.sidebar').find('ul').hide();

// good
$('.sidebar ul').hide();

// good
$('.sidebar &amp;gt; ul').hide();

// good (slower)
$sidebar.find('ul');

// good (faster)
$($sidebar[0]).find('ul');
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;#TOC&quot;&gt;[⬆]&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Tue, 31 Mar 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/31/javascript_guide</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/31/javascript_guide</guid>
			</item>

			<item>
				<title>CSS规范</title>
				<description>&lt;h1 id=&quot;css编码规范&quot;&gt;CSS编码规范&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-1-前言&quot;&gt;1 前言&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-2-代码风格&quot;&gt;2 代码风格&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-21-文件&quot;&gt;2.1 文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-22-缩进&quot;&gt;2.2 缩进&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-23-空格&quot;&gt;2.3 空格&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-24-行长度&quot;&gt;2.4 行长度&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-25-选择器&quot;&gt;2.5 选择器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-26-属性&quot;&gt;2.6 属性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-3-通用&quot;&gt;3 通用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-31-选择器&quot;&gt;3.1 选择器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-32-属性缩写&quot;&gt;3.2 属性缩写&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-33-属性书写顺序&quot;&gt;3.3 属性书写顺序&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-34-清除浮动&quot;&gt;3.4 清除浮动&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-35-important&quot;&gt;3.5 !important&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-36-z-index&quot;&gt;3.6 z-index&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-4-值与单位&quot;&gt;4 值与单位&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-41-文本&quot;&gt;4.1 文本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-42-数值&quot;&gt;4.2 数值&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-43-url&quot;&gt;4.3 url()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-44-长度&quot;&gt;4.4 长度&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-45-颜色&quot;&gt;4.5 颜色&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-46-2d-位置&quot;&gt;4.6 2D 位置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-5-文件编排&quot;&gt;5 文本编排&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-51-字体族&quot;&gt;5.1 字体族&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-52-字号&quot;&gt;5.2 字号&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-53-字体风格&quot;&gt;5.3 字体风格&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-54-字重&quot;&gt;5.4 字重&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-55-行高&quot;&gt;5.5 行高&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-6-变换与动画&quot;&gt;6 变换与动画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-7-响应式&quot;&gt;7 响应式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#user-content-8-兼容性&quot;&gt;8 兼容性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-81-属性前缀&quot;&gt;8.1 属性前缀&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-82-hack&quot;&gt;8.2 Hack&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;#user-content-83-expression&quot;&gt;8.3 Expression&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-前言&quot;&gt;1 前言&lt;/h2&gt;

&lt;p&gt;CSS作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使CSS代码风格保持一致，容易被理解和被维护。&lt;/p&gt;

&lt;p&gt;虽然本文档是针对CSS设计的，但是在使用各种CSS的预编译器(如less、sass、stylus等)时，适用的部分也应尽量遵循本文档的约定。&lt;/p&gt;

&lt;h2 id=&quot;2-代码风格&quot;&gt;2 代码风格&lt;/h2&gt;

&lt;h3 id=&quot;21-文件&quot;&gt;2.1 文件&lt;/h3&gt;

&lt;h4 id=&quot;建议--文件使用无--的--编码&quot;&gt;[建议] &lt;code&gt;CSS&lt;/code&gt; 文件使用无 &lt;code&gt;BOM&lt;/code&gt; 的 &lt;code&gt;UTF-8&lt;/code&gt; 编码。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。&lt;/p&gt;

&lt;h3 id=&quot;22-缩进&quot;&gt;2.2 缩进&lt;/h3&gt;

&lt;h4 id=&quot;强制-使用--个空格做为一个缩进层级不允许使用--个空格-或--字符&quot;&gt;[强制] 使用 &lt;code&gt;4&lt;/code&gt; 个空格做为一个缩进层级，不允许使用 &lt;code&gt;2&lt;/code&gt; 个空格 或 &lt;code&gt;tab&lt;/code&gt; 字符。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.selector {
    margin: 0;
    padding: 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;23-空格&quot;&gt;2.3 空格&lt;/h3&gt;

&lt;h4 id=&quot;强制--与--之间必须包含空格&quot;&gt;[强制] &lt;code&gt;选择器&lt;/code&gt; 与 &lt;code&gt;{&lt;/code&gt; 之间必须包含空格。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.selector {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制--与之后的--之间不允许包含空格--与--之间必须包含空格&quot;&gt;[强制] &lt;code&gt;属性名&lt;/code&gt; 与之后的 &lt;code&gt;:&lt;/code&gt; 之间不允许包含空格， &lt;code&gt;:&lt;/code&gt; 与 &lt;code&gt;属性值&lt;/code&gt; 之间必须包含空格。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;margin: 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制--书写在单行时-后必须跟一个空格&quot;&gt;[强制] &lt;code&gt;列表型属性值&lt;/code&gt; 书写在单行时，&lt;code&gt;,&lt;/code&gt; 后必须跟一个空格。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;font-family: Arial, sans-serif;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;24-行长度&quot;&gt;2.4 行长度&lt;/h3&gt;

&lt;h4 id=&quot;强制-每行不得超过--个字符除非单行不可分割&quot;&gt;[强制] 每行不得超过 &lt;code&gt;120&lt;/code&gt; 个字符，除非单行不可分割。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;常见不可分割的场景为URL超长。&lt;/p&gt;

&lt;h4 id=&quot;建议-对于超长的样式在样式值的--处或--后换行建议按逻辑分组&quot;&gt;[建议] 对于超长的样式，在样式值的 &lt;code&gt;空格&lt;/code&gt; 处或 &lt;code&gt;,&lt;/code&gt; 后换行，建议按逻辑分组。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* 不同属性值按逻辑分组 */
background:
    transparent url(aVeryVeryVeryLongUrlIsPlacedHere)
    no-repeat 0 0;

/* 可重复多次的属性，每次重复一行 */
background-image:
    url(aVeryVeryVeryLongUrlIsPlacedHere)
    url(anotherVeryVeryVeryLongUrlIsPlacedHere);

/* 类似函数的属性值可以根据函数调用的缩进进行 */
background-image: -webkit-gradient(
    linear,
    left bottom,
    left top,
    color-stop(0.04, rgb(88,94,124)),
    color-stop(0.52, rgb(115,123,162))
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;25-选择器&quot;&gt;2.5 选择器&lt;/h3&gt;

&lt;h4 id=&quot;强制-当一个-rule-包含多个-selector-时每个选择器声明必须独占一行&quot;&gt;[强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.post,
.page,
.comment {
    line-height: 1.5;
}

/* bad */
.post, .page, .comment {
    line-height: 1.5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制--选择器的两边各保留一个空格&quot;&gt;[强制] &lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt; 选择器的两边各保留一个空格。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
main &amp;gt; nav {
    padding: 10px;
}

label + input {
    margin-left: 5px;
}

input:checked ~ button {
    background-color: #69C;
}

/* bad */
main&amp;gt;nav {
    padding: 10px;
}

label+input {
    margin-left: 5px;
}

input:checked~button {
    background-color: #69C;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-属性选择器中的值必须用双引号包围&quot;&gt;[强制] 属性选择器中的值必须用双引号包围。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;不允许使用单引号，不允许不使用引号。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
article[character=&quot;juliet&quot;] {
    voice-family: &quot;Vivien Leigh&quot;, victoria, female
}

/* bad */
article[character='juliet'] {
    voice-family: &quot;Vivien Leigh&quot;, victoria, female
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;26-属性&quot;&gt;2.6 属性&lt;/h3&gt;

&lt;h4 id=&quot;强制-属性定义必须另起一行&quot;&gt;[强制] 属性定义必须另起一行。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.selector {
    margin: 0;
    padding: 0;
}

/* bad */
.selector { margin: 0; padding: 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-属性定义后必须以分号结尾&quot;&gt;[强制] 属性定义后必须以分号结尾。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.selector {
    margin: 0;
}

/* bad */
.selector {
    margin: 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;3-通用&quot;&gt;3 通用&lt;/h2&gt;

&lt;h3 id=&quot;31-选择器&quot;&gt;3.1 选择器&lt;/h3&gt;

&lt;h4 id=&quot;强制-如无必要不得为--选择器添加类型选择器进行限定&quot;&gt;[强制] 如无必要，不得为 &lt;code&gt;id&lt;/code&gt;、&lt;code&gt;class&lt;/code&gt; 选择器添加类型选择器进行限定。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;在性能和维护性上，都有一定的影响。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
#error,
.danger-message {
    font-color: #c00;
}

/* bad */
dialog#error,
p.danger-message {
    font-color: #c00;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-选择器的嵌套层级应不大于-3-级位置靠后的限定条件应尽可能精确&quot;&gt;[建议] 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
#username input {}
.comment .avatar {}

/* bad */
.page .header .login #username input {}
.comment div * {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;32-属性缩写&quot;&gt;3.2 属性缩写&lt;/h3&gt;

&lt;h4 id=&quot;建议-在可以使用缩写的情况下尽量使用属性缩写&quot;&gt;[建议] 在可以使用缩写的情况下，尽量使用属性缩写。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.post {
    font: 12px/1.5 arial, sans-serif;
}

/* bad */
.post {
    font-family: arial, sans-serif;
    font-size: 12px;
    line-height: 1.5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-使用------等缩写时应注意隐含值对实际数值的影响确实需要设置多个方向的值时才使用缩写&quot;&gt;[建议] 使用 &lt;code&gt;border&lt;/code&gt; / &lt;code&gt;margin&lt;/code&gt; / &lt;code&gt;padding&lt;/code&gt; 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;border / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* centering &amp;lt;article class=&quot;page&quot;&amp;gt; horizontally and highlight featured ones */
article {
    margin: 5px;
    border: 1px solid #999;
}

/* good */
.page {
    margin-right: auto;
    margin-left: auto;
}

.featured {
    border-color: #69c;
}

/* bad */
.page {
    margin: 5px auto; /* introducing redundancy */
}

.featured {
    border: 1px solid #69c; /* introducing redundancy */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;33-属性书写顺序&quot;&gt;3.3 属性书写顺序&lt;/h3&gt;

&lt;h4 id=&quot;建议-同一-rule-set-下的属性在书写时应按功能进行分组并以-formatting-model布局方式位置--box-model尺寸--typographic文本相关--visual视觉效果-的顺序书写以提高代码的可读性&quot;&gt;[建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 &lt;strong&gt;Formatting Model（布局方式、位置） &amp;gt; Box Model（尺寸） &amp;gt; Typographic（文本相关） &amp;gt; Visual（视觉效果）&lt;/strong&gt; 的顺序书写，以提高代码的可读性。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Formatting Model 相关属性包括：&lt;code&gt;position&lt;/code&gt; / &lt;code&gt;top&lt;/code&gt; / &lt;code&gt;right&lt;/code&gt; / &lt;code&gt;bottom&lt;/code&gt; / &lt;code&gt;left&lt;/code&gt; / &lt;code&gt;float&lt;/code&gt; / &lt;code&gt;display&lt;/code&gt; / &lt;code&gt;overflow&lt;/code&gt; 等&lt;/li&gt;
  &lt;li&gt;Box Model 相关属性包括：&lt;code&gt;border&lt;/code&gt; / &lt;code&gt;margin&lt;/code&gt; / &lt;code&gt;padding&lt;/code&gt; / &lt;code&gt;width&lt;/code&gt; / &lt;code&gt;height&lt;/code&gt; 等&lt;/li&gt;
  &lt;li&gt;Typographic 相关属性包括：&lt;code&gt;font&lt;/code&gt; / &lt;code&gt;line-height&lt;/code&gt; / &lt;code&gt;text-align&lt;/code&gt; / &lt;code&gt;word-wrap&lt;/code&gt; 等&lt;/li&gt;
  &lt;li&gt;Visual 相关属性包括：&lt;code&gt;background&lt;/code&gt; / &lt;code&gt;color&lt;/code&gt; / &lt;code&gt;transition&lt;/code&gt; / &lt;code&gt;list-style&lt;/code&gt; 等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，如果包含 &lt;code&gt;content&lt;/code&gt; 属性，应放在最前面。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.sidebar {
    /* formatting model: positioning schemes / offsets / z-indexes / display / ...  */
    position: absolute;
    top: 50px;
    left: 0;
    overflow-x: hidden;

    /* box model: sizes / margins / paddings / borders / ...  */
    width: 200px;
    padding: 5px;
    border: 1px solid #ddd;

    /* typographic: font / aligns / text styles / ... */
    font-size: 14px;
    line-height: 20px;

    /* visual: colors / shadows / gradients / ... */
    background: #f5f5f5;
    color: #333;
    -webkit-transition: color 1s;
       -moz-transition: color 1s;
            transition: color 1s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;34-清除浮动&quot;&gt;3.4 清除浮动&lt;/h3&gt;

&lt;h4 id=&quot;建议-当元素需要撑起高度以包含内部的浮动元素时通过对伪类设置--或触发--的方式进行-尽量不使用增加空标签的方式&quot;&gt;[建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 &lt;code&gt;clear&lt;/code&gt; 或触发 &lt;code&gt;BFC&lt;/code&gt; 的方式进行 &lt;code&gt;clearfix&lt;/code&gt;。尽量不使用增加空标签的方式。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;触发 BFC 的方式很多，常见的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;float 非 none&lt;/li&gt;
  &lt;li&gt;position 非 static&lt;/li&gt;
  &lt;li&gt;overflow 非 visible&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如希望使用更小副作用的清除浮动方法，参见 &lt;a href=&quot;http://nicolasgallagher.com/micro-clearfix-hack/&quot;&gt;A new micro clearfix hack&lt;/a&gt; 一文。&lt;/p&gt;

&lt;p&gt;另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。&lt;/p&gt;

&lt;h3 id=&quot;35-important&quot;&gt;3.5 !important&lt;/h3&gt;

&lt;h4 id=&quot;建议-尽量不使用--声明&quot;&gt;[建议] 尽量不使用 &lt;code&gt;!important&lt;/code&gt; 声明。&lt;/h4&gt;

&lt;h4 id=&quot;建议-当需要强制指定样式且不允许任何场景覆盖时通过标签内联和--定义样式&quot;&gt;[建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 &lt;code&gt;!important&lt;/code&gt; 定义样式。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;必须注意的是，仅在设计上 &lt;code&gt;确实不允许任何其它场景覆盖样式&lt;/code&gt; 时，才使用内联的 &lt;code&gt;!important&lt;/code&gt; 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。&lt;/p&gt;

&lt;h3 id=&quot;36-z-index&quot;&gt;3.6 z-index&lt;/h3&gt;

&lt;h4 id=&quot;建议-将--进行分层对文档流外绝对定位元素的视觉层级关系进行管理&quot;&gt;[建议] 将 &lt;code&gt;z-index&lt;/code&gt; 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 &lt;code&gt;z-index&lt;/code&gt; 或递增 &lt;code&gt;z-index&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;建议每层包含100个 &lt;code&gt;z-index&lt;/code&gt; 来容纳足够的元素，如果每层元素较多，可以调整这个数值。&lt;/p&gt;

&lt;h4 id=&quot;建议-在可控环境下期望显示在最上层的元素-指定为-&quot;&gt;[建议] 在可控环境下，期望显示在最上层的元素，&lt;code&gt;z-index&lt;/code&gt; 指定为 &lt;code&gt;999999&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。&lt;/p&gt;

&lt;p&gt;不建议取值为 &lt;code&gt;2147483647&lt;/code&gt;。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。&lt;/p&gt;

&lt;h4 id=&quot;建议-在第三方环境下期望显示在最上层的元素通过标签内联和-将--指定为-&quot;&gt;[建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 &lt;code&gt;!important&lt;/code&gt;，将 &lt;code&gt;z-index&lt;/code&gt; 指定为 &lt;code&gt;2147483647&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。&lt;/p&gt;

&lt;h2 id=&quot;4-值与单位&quot;&gt;4 值与单位&lt;/h2&gt;

&lt;h3 id=&quot;41-文本&quot;&gt;4.1 文本&lt;/h3&gt;

&lt;h4 id=&quot;强制-文本内容必须用双引号包围&quot;&gt;[强制] 文本内容必须用双引号包围。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;文本类型的内容可能在选择器、属性值等内容中。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
html[lang|=&quot;zh&quot;] q:before {
    font-family: &quot;Microsoft YaHei&quot;, sans-serif;
    content: &quot;“&quot;;
}

html[lang|=&quot;zh&quot;] q:after {
    font-family: &quot;Microsoft YaHei&quot;, sans-serif;
    content: &quot;”&quot;;
}

/* bad */
html[lang|=zh] q:before {
    font-family: 'Microsoft YaHei', sans-serif;
    content: '“';
}

html[lang|=zh] q:after {
    font-family: &quot;Microsoft YaHei&quot;, sans-serif;
    content: &quot;”&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;42-数值&quot;&gt;4.2 数值&lt;/h3&gt;

&lt;h4 id=&quot;强制-当数值为-0---1-之间的小数时省略整数部分的-&quot;&gt;[强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 &lt;code&gt;0&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
panel {
    opacity: .8
}

/* bad */
panel {
    opacity: 0.8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;43-url&quot;&gt;4.3 url()&lt;/h3&gt;

&lt;h4 id=&quot;强制--函数中的路径不加引号&quot;&gt;[强制] &lt;code&gt;url()&lt;/code&gt; 函数中的路径不加引号。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;body {
    background: url(bg.png);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议--函数中的绝对路径可省去协议名&quot;&gt;[建议] &lt;code&gt;url()&lt;/code&gt; 函数中的绝对路径可省去协议名。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;body {
    background: url(//baidu.com/img/bg.png) no-repeat 0 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;44-长度&quot;&gt;4.4 长度&lt;/h3&gt;

&lt;h4 id=&quot;强制-长度为--时须省略单位-也只有长度单位可省&quot;&gt;[强制] 长度为 &lt;code&gt;0&lt;/code&gt; 时须省略单位。 (也只有长度单位可省)&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
body {
    padding: 0 5px;
}

/* bad */
body {
    padding: 0px 5px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;45-颜色&quot;&gt;4.5 颜色&lt;/h3&gt;

&lt;h4 id=&quot;强制-rgb颜色值必须使用十六进制记号形式-不允许使用-&quot;&gt;[强制] RGB颜色值必须使用十六进制记号形式 &lt;code&gt;#rrggbb&lt;/code&gt;。不允许使用 &lt;code&gt;rgb()&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;带有alpha的颜色信息可以使用 &lt;code&gt;rgba()&lt;/code&gt;。使用 &lt;code&gt;rgba()&lt;/code&gt; 时每个逗号后必须保留一个空格。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.success {
    box-shadow: 0 0 2px rgba(0, 128, 0, .3);
    border-color: #008000;
}

/* bad */
.success {
    box-shadow: 0 0 2px rgba(0,128,0,.3);
    border-color: rgb(0, 128, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-颜色值可以缩写时必须使用缩写形式&quot;&gt;[强制] 颜色值可以缩写时，必须使用缩写形式。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.success {
    background-color: #aca;
}

/* bad */
.success {
    background-color: #aaccaa;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制-颜色值不允许使用命名色值&quot;&gt;[强制] 颜色值不允许使用命名色值。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.success {
    color: #90ee90;
}

/* bad */
.success {
    color: lightgreen;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-颜色值中的英文字符采用小写如不用小写也需要保证同一项目内保持大小写一致&quot;&gt;[建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.success {
    background-color: #aca;
    color: #90ee90;
}

/* good */
.success {
    background-color: #ACA;
    color: #90EE90;
}

/* bad */
.success {
    background-color: #ACA;
    color: #90ee90;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;46-2d-位置&quot;&gt;4.6 2D 位置&lt;/h3&gt;

&lt;h4 id=&quot;强制-必须同时给出水平和垂直方向的位置&quot;&gt;[强制] 必须同时给出水平和垂直方向的位置。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;2D 位置初始值为 &lt;code&gt;0% 0%&lt;/code&gt;，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。&lt;a href=&quot;http://www.w3.org/TR/CSS21/colors.html#propdef-background-position&quot;&gt;background-position属性值的定义&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
body {
    background-position: center top; /* 50% 0% */
}

/* bad */
body {
    background-position: top; /* 50% 0% */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;5-文本编排&quot;&gt;5 文本编排&lt;/h2&gt;

&lt;h3 id=&quot;51-字体族&quot;&gt;5.1 字体族&lt;/h3&gt;

&lt;h4 id=&quot;强制--属性中的字体族名称应使用字体的英文-其中如有空格须放置在引号中&quot;&gt;[强制] &lt;code&gt;font-family&lt;/code&gt; 属性中的字体族名称应使用字体的英文 &lt;code&gt;Family Name&lt;/code&gt;，其中如有空格，须放置在引号中。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;所谓英文 Family Name，为字体文件的一个元数据，常见名称如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字体&lt;/th&gt;
      &lt;th&gt;操作系统&lt;/th&gt;
      &lt;th&gt;Family Name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;宋体 (中易宋体)&lt;/td&gt;
      &lt;td&gt;Windows&lt;/td&gt;
      &lt;td&gt;SimSun&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;黑体 (中易黑体)&lt;/td&gt;
      &lt;td&gt;Windows&lt;/td&gt;
      &lt;td&gt;SimHei&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;微软雅黑&lt;/td&gt;
      &lt;td&gt;Windows&lt;/td&gt;
      &lt;td&gt;Microsoft YaHei&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;微软正黑&lt;/td&gt;
      &lt;td&gt;Windows&lt;/td&gt;
      &lt;td&gt;Microsoft JhengHei&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;华文黑体&lt;/td&gt;
      &lt;td&gt;Mac/iOS&lt;/td&gt;
      &lt;td&gt;STHeiti&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;冬青黑体&lt;/td&gt;
      &lt;td&gt;Mac/iOS&lt;/td&gt;
      &lt;td&gt;Hiragino Sans GB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;文泉驿正黑&lt;/td&gt;
      &lt;td&gt;Linux&lt;/td&gt;
      &lt;td&gt;WenQuanYi Zen Hei&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;文泉驿微米黑&lt;/td&gt;
      &lt;td&gt;Linux&lt;/td&gt;
      &lt;td&gt;WenQuanYi Micro Hei&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;h1 {
    font-family: &quot;Microsoft YaHei&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制--按西文字体在前中文字体在后效果佳-质量高更能满足需求-的字体在前效果一般的字体在后的顺序编写最后必须指定一个通用字体族----&quot;&gt;[强制] &lt;code&gt;font-family&lt;/code&gt; 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( &lt;code&gt;serif&lt;/code&gt; / &lt;code&gt;sans-serif&lt;/code&gt; )。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;更详细说明可参考&lt;a href=&quot;http://www.zhihu.com/question/19911793/answer/13329819&quot;&gt;本文&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* Display according to platform */
.article {
    font-family: Arial, sans-serif;
}

/* Specific for most platforms */
h1 {
    font-family: &quot;Helvetica Neue&quot;, Arial, &quot;Hiragino Sans GB&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft YaHei&quot;, sans-serif;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制--不区分大小写但在同一个项目中同样的--大小写必须统一&quot;&gt;[强制] &lt;code&gt;font-family&lt;/code&gt; 不区分大小写，但在同一个项目中，同样的 &lt;code&gt;Family Name&lt;/code&gt; 大小写必须统一。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
body {
    font-family: Arial, sans-serif;
}

h1 {
    font-family: Arial, &quot;Microsoft YaHei&quot;, sans-serif;
}

/* bad */
body {
    font-family: arial, sans-serif;
}

h1 {
    font-family: Arial, &quot;Microsoft YaHei&quot;, sans-serif;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;52-字号&quot;&gt;5.2 字号&lt;/h3&gt;

&lt;h4 id=&quot;强制-需要在-windows-平台显示的中文内容其字号应不小于-&quot;&gt;[强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 &lt;code&gt;12px&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。&lt;/p&gt;

&lt;h3 id=&quot;53-字体风格&quot;&gt;5.3 字体风格&lt;/h3&gt;

&lt;h4 id=&quot;建议-需要在-windows-平台显示的中文内容不要使用除--外的-其他平台也应慎用&quot;&gt;[建议] 需要在 Windows 平台显示的中文内容，不要使用除 &lt;code&gt;normal&lt;/code&gt; 外的 &lt;code&gt;font-style&lt;/code&gt;。其他平台也应慎用。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。&lt;/p&gt;

&lt;h3 id=&quot;54-字重&quot;&gt;5.4 字重&lt;/h3&gt;

&lt;h4 id=&quot;强制--属性必须使用数值方式描述&quot;&gt;[强制] &lt;code&gt;font-weight&lt;/code&gt; 属性必须使用数值方式描述。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。&lt;/p&gt;

&lt;p&gt;浏览器本身使用一系列&lt;a href=&quot;http://www.w3.org/TR/CSS21/fonts.html#propdef-font-weight&quot;&gt;启发式规则&lt;/a&gt;来进行匹配，在 &amp;lt;700 时一般匹配字体的 Regular 字重，&amp;gt;=700 时匹配 Bold 字重。&lt;/p&gt;

&lt;p&gt;但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见&lt;a href=&quot;http://justineo.github.io/slideshows/font/#/3/15&quot;&gt;此表&lt;/a&gt;)，故使用数值描述增加了灵活性，也更简短。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
h1 {
    font-weight: 700;
}

/* bad */
h1 {
    font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;55-行高&quot;&gt;5.5 行高&lt;/h3&gt;

&lt;h4 id=&quot;建议--在定义文本段落时应使用数值&quot;&gt;[建议] &lt;code&gt;line-height&lt;/code&gt; 在定义文本段落时，应使用数值。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。&lt;/p&gt;

&lt;p&gt;当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.container {
    line-height: 1.5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;6-变换与动画&quot;&gt;6 变换与动画&lt;/h2&gt;

&lt;h4 id=&quot;强制-使用--时应指定-&quot;&gt;[强制] 使用 &lt;code&gt;transition&lt;/code&gt; 时应指定 &lt;code&gt;transition-property&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.box {
    transition: color 1s, border-color 1s;
}

/* bad */
.box {
    transition: all 1s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-尽可能在浏览器能高效实现的属性上添加过渡和动画&quot;&gt;[建议] 尽可能在浏览器能高效实现的属性上添加过渡和动画。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;见&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/&quot;&gt;本文&lt;/a&gt;，在可能的情况下应选择这样四种变换：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;transform: translate(npx, npx);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;transform: scale(n);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;transform: rotate(ndeg);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;opacity: 0..1;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;典型的，可以使用 translate 来代替 left 作为动画属性。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* good */
.box {
    transition: transform 1s;
}
.box:hover {
    transform: translate(20px); /* move right for 20px */
}

/* bad */
.box {
    left: 0;
    transition: left 1s;
}
.box:hover {
    left: 20px; /* move right for 20px */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;7-响应式&quot;&gt;7 响应式&lt;/h2&gt;

&lt;h4 id=&quot;强制--不得单独编排必须与相关的规则一起定义&quot;&gt;[强制] &lt;code&gt;Media Query&lt;/code&gt; 不得单独编排，必须与相关的规则一起定义。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* Good */
/* header styles */
@media (...) {
    /* header styles */
}

/* main styles */
@media (...) {
    /* main styles */
}

/* footer styles */
@media (...) {
    /* footer styles */
}


/* Bad */
/* header styles */
/* main styles */
/* footer styles */

@media (...) {
    /* header styles */
    /* main styles */
    /* footer styles */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;强制--如果有多个逗号分隔的条件时应将每个条件放在单独一行中&quot;&gt;[强制] &lt;code&gt;Media Query&lt;/code&gt; 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;@media
(-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */
(min--moz-device-pixel-ratio: 2),    /* Older Firefox browsers (prior to Firefox 16) */
(min-resolution: 2dppx),             /* The standard way */
(min-resolution: 192dpi) {           /* dppx fallback */
    /* Retina-specific stuff here */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-尽可能给出在高分辨率设备-retina-下效果更佳的样式&quot;&gt;[建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。&lt;/h4&gt;

&lt;h2 id=&quot;8-兼容性&quot;&gt;8 兼容性&lt;/h2&gt;

&lt;h3 id=&quot;81-属性前缀&quot;&gt;8.1 属性前缀&lt;/h3&gt;

&lt;h4 id=&quot;强制-带私有前缀的属性由长到短排列按冒号位置对齐&quot;&gt;[强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.box {
    -webkit-box-sizing: border-box;
       -moz-box-sizing: border-box;
            box-sizing: border-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;82-hack&quot;&gt;8.2 Hack&lt;/h3&gt;

&lt;h4 id=&quot;建议-需要添加--时应尽可能考虑是否可以采用其他方式解决&quot;&gt;[建议] 需要添加 &lt;code&gt;hack&lt;/code&gt; 时应尽可能考虑是否可以采用其他方式解决。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。&lt;/p&gt;

&lt;h4 id=&quot;建议-尽量使用--处理兼容性而非-&quot;&gt;[建议] 尽量使用 &lt;code&gt;选择器 hack&lt;/code&gt; 处理兼容性，而非 &lt;code&gt;属性 hack&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;p&gt;尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* IE 7 */
*:first-child + html #header {
    margin-top: 3px;
    padding: 5px;
}

/* IE 6 */
* html #header {
    margin-top: 5px;
    padding: 4px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;建议-尽量使用简单的-&quot;&gt;[建议] 尽量使用简单的 &lt;code&gt;属性 hack&lt;/code&gt;。&lt;/h4&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.box {
    _display: inline; /* fix double margin */
    float: left;
    margin-left: 20px;
}

.container {
    overflow: hidden;
    *zoom: 1; /* triggering hasLayout */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;83-expression&quot;&gt;8.3 Expression&lt;/h3&gt;

&lt;h4 id=&quot;强制-禁止使用-&quot;&gt;[强制] 禁止使用 &lt;code&gt;Expression&lt;/code&gt;。&lt;/h4&gt;

</description>
				<pubDate>Tue, 31 Mar 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/31/css_guide</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/31/css_guide</guid>
			</item>

			<item>
				<title>前端小技巧总结</title>
				<description>&lt;h3 id=&quot;生成随机字符串&quot;&gt;生成随机字符串&lt;/h3&gt;

&lt;p&gt;利用&lt;code&gt;Math.random&lt;/code&gt;和&lt;code&gt;toString&lt;/code&gt;生成随机字符串，来自前一阵子看到的一篇博文。这里的技巧是利用了&lt;code&gt;toString&lt;/code&gt;方法可以接收一个基数作为参数的原理，这个基数从2到36封顶。如果不指定，默认基数是10进制。略屌！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function generateRandomAlphaNum(len) {
    var rdmString = &quot;&quot;;
    for (; rdmString.length &amp;lt; len; rdmString += Math.random().toString(36).substr(2));
    return rdmString.substr(0, len);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;整数的操作&quot;&gt;整数的操作&lt;/h3&gt;

&lt;p&gt;JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;|0和~~&lt;/code&gt;是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt,Math.round 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var foo = (12.4 / 4.13) | 0;//结果为3
var bar = ~~(12.4 / 4.13);//结果为3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便说句，&lt;code&gt;!!&lt;/code&gt;将一个值方便快速转化为布尔值 &lt;code&gt;!!window===true&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;if语句的变形&quot;&gt;If语句的变形&lt;/h3&gt;

&lt;p&gt;当你需要写一个if语句的时候，不妨尝试另一种更简便的方法，用JavaScript中的逻辑操作符来代替。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var day=(new Date).getDay()===0;
//传统if语句
if (day) {
	alert('Today is Sunday!');
};
//运用逻辑与代替if
day&amp;amp;&amp;amp;alert('Today is Sunday!');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的day变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的alert了，如果前面day为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了if的效果。&lt;/p&gt;

&lt;h3 id=&quot;禁止别人以iframe加载你的页面&quot;&gt;禁止别人以iframe加载你的页面&lt;/h3&gt;

&lt;p&gt;下面的代码已经不言自明了，没什么好多说的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if (window.location != window.parent.location) window.parent.location = window.location;

console.table
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;chrome专属ie绕道的console方法&quot;&gt;Chrome专属，IE绕道的console方法&lt;/h3&gt;

&lt;p&gt;可以将JavaScript关联数组以表格形式输出到浏览器console，效果很惊赞，界面很美观。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//采购情况
var data = [{'品名': '杜雷斯', '数量': 4}, {'品名': '冈本', '数量': 3}];
console.table(data);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;浏览器小技巧&quot;&gt;浏览器小技巧&lt;/h3&gt;

&lt;p&gt;Chrome Canary 开发者工具可以控制 CSS3 动画的暂停以及速度啦！&lt;/p&gt;

&lt;p&gt;Chrome 打开 DevTools 之后，右击或者一直摁住刷新键，会出来清缓存强制刷新的功能选项( tip from Addy Osmani ) ，其中「硬性重新加载」类似于强制刷新。&lt;/p&gt;

&lt;p&gt;Chrome DevTools 的 Network 面板现在支持使用「-」反向搜索了。例如输入「-.js」会筛选出所有非 JS 的请求。&lt;/p&gt;

&lt;p&gt;在 Chrome 和 Safari 的开发中工具中，可以按「H」键快速隐藏元素。&lt;/p&gt;

&lt;p&gt;chrome开发工具技巧：用放大镜选中了某个DOM之后，在console中输入$0，就得到当前DOM的引用，临时调试起来就方便很多了！&lt;/p&gt;
</description>
				<pubDate>Mon, 16 Mar 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/16/javascript_tip</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/16/javascript_tip</guid>
			</item>

			<item>
				<title>用pm2管理node进程</title>
				<description>&lt;p&gt;在这篇博客中，我将介绍使用PM2对NodeJS应用进行监控管理。&lt;/p&gt;

&lt;p&gt;PM2是NodeJS应用的进程管理器。它的一个特点是自动使用Node的 Cluster API。 PM2使应用程序能够运行多个进程,通常不需要修改它。&lt;/p&gt;

&lt;p&gt;PM2 是一个带有负载均衡功能的Node应用的进程管理器.&lt;/p&gt;

&lt;p&gt;当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。它非常适合IaaS结构。&lt;/p&gt;

&lt;p&gt;我们将讨论安装，配置和使用PM2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g pm2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Web Interface (JSON API)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PM2以一个JSON API的形式配备了web接口。我们可以开始运行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm2 web

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个web监听端口9615.这个Web接口实际上是一个监控程序。我们可以检查任何监视的处理，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# List processes monitored
pm2 list

# See &quot;tail&quot; style log output of all logs output from watched processes
pm2 logs

# Clear all logs
pm2 flush

# List process 0 (the web interface in this case)
pm2 desc 0

# Monitor processes and system usage
pm2 monit

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是web接口：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2015-03-13/1.png&quot; alt=&quot;pm2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;运行应用程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运行一个应用程序与PM2相当直白:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm2 start app.js --name &quot;myapp&quot; -i max
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让我们探讨一下这个命令:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;–start app.js ——运行和监视应用程序&lt;/li&gt;
  &lt;li&gt;–name ——应用程序的名称,所以我们可以参考其他命令&lt;/li&gt;
  &lt;li&gt;–i max ——运行多个应用程序的过程。 每个CPU核心PM2将运行一个进程。 它还将试图运行的进程之间的负载平衡的请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的应用叫 myapp 我们可以使用其他命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Reload and restart the application
pm2 reload myapp

# Stop the application
pm2 stop myapp

# Remove myapp from PM2
pm2 delete myapp

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有其他一些命令可以使用,如 gracefulReload 重新启动之前,用于关闭所有现有的连接。&lt;/p&gt;

&lt;p&gt;现在我们可以看到web界面和应用监控:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2015-03-13/2.png&quot; alt=&quot;pm2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面就是PM2 monit的命令界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2015-03-13/3.jpg&quot; alt=&quot;pm2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;今天就介绍这么多&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Unitech/pm2&quot;&gt;pm2 github地址&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Fri, 13 Mar 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/13/pm2</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/13/pm2</guid>
			</item>

			<item>
				<title>pm2-web监控node.js应用服务状态</title>
				<description>&lt;p&gt;pm2是一款非常好用的Node.js服务启动容器，可以完全替代之前使用的node-forever&lt;/p&gt;

&lt;p&gt;但是pm2只是一个命令行程序，pm2 web命令虽然可以提供一些服务器的监测信息，但是是JSON格式的，不易读。&lt;/p&gt;

&lt;p&gt;pm2-web便是一个基于web的pm2应用监测程序，它可以提供一个较好友好的界面来显示服务器资源状态，同时还可以重启或关停某个子进程，比较实用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装pm2-web&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装很简单，通过npm一条命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g pm2-web

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完之后便可以启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm2-web

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启动配置项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有一些配置选项，通常需要指定一下–ws:host为外网可访问域名，否则打开页面时会提示Socket Error.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–www:port 9000 Web页面访问端口号

–mdns:name pm2-web 支持mdns服务协议

–ws:port 9001 WebSocket监听端口号

–ws:host 127.0.0.1 WebSocket监听域名

–updateFrequency 5000 数据刷新时间间隔

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;指定pm2服务配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以指定pm2服务的一些配置信息，如host, rpc 端口等，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pm2-web

    --pm2.host localhost
    --pm2.rpc 6666
    --pm2.events 6667
    --pm2.host another.host
    --pm2.rpc 6666
    --pm2.events 6667

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;nohup 后台执行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup pm2-web

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2015-03-13/4.png&quot; alt=&quot;pm2-web&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 13 Mar 2015 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/13/pm2-web</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2015/03/13/pm2-web</guid>
			</item>

			<item>
				<title>node.js升级</title>
				<description>&lt;p&gt;今天，又发现一个超级简单的升级node.js的方法。一行命令搞定，省去了重新编译安装的过程。&lt;/p&gt;

&lt;p&gt;node有一个模块叫n（这名字可够短的。。。），是专门用来管理node.js的版本的。
首先安装n模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
npm install -g n

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步：&lt;/p&gt;

&lt;p&gt;升级node.js到最新稳定版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
n stable

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很简单？！&lt;/p&gt;

&lt;p&gt;n后面也可以跟随版本号比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
n v0.10.29

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
n 0.10.29

&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Wed, 13 Aug 2014 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/08/13/nodejs_update</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/08/13/nodejs_update</guid>
			</item>

			<item>
				<title>开源书籍</title>
				<description>&lt;p&gt;书籍第一发：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ssy.me/web_go/&quot;&gt;《Go Web 编程》&lt;/a&gt; （2014-12-23）&lt;/p&gt;

&lt;p&gt;书籍第二发：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ssy.me/go_program/&quot;&gt;《Go 语言编程》&lt;/a&gt;  (2014-12-24）&lt;/p&gt;
</description>
				<pubDate>Wed, 13 Aug 2014 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E6%9D%82%E8%B0%88/2014/08/13/books</link>
				<guid isPermaLink="true">http://ssy.me/%E6%9D%82%E8%B0%88/2014/08/13/books</guid>
			</item>

			<item>
				<title>Canvas API</title>
				<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;Canvas API（画布）用于在网页实时生成图像，并且可以操作图像内容，基本上它是一个可以用JavaScript操作的位图（bitmap）。&lt;/p&gt;

&lt;p&gt;使用前，首先需要新建一个canvas网页元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&amp;gt;
    您的浏览器不支持canvas！
&amp;lt;/canvas&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，如果浏览器不支持这个API，则就会显示canvas标签中间的文字——“您的浏览器不支持canvas！”。&lt;/p&gt;

&lt;p&gt;每个canvas元素都有一个对应的context对象（上下文对象），Canvas API定义在这个context对象上面，所以需要获取这个对象，方法是使用getContext方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var canvas = document.getElementById('myCanvas');

if (canvas.getContext) {
	var ctx = canvas.getContext('2d');
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，getContext方法指定参数2d，表示该canvas对象用于生成2D图案（即平面图案）。如果参数是3d，就表示用于生成3D图像（即立体图案），这部分实际上单独叫做WebGL API（本书不涉及）。&lt;/p&gt;

&lt;h2 id=&quot;绘图方法&quot;&gt;绘图方法&lt;/h2&gt;

&lt;p&gt;canvas画布提供了一个用来作图的平面空间，该空间的每个点都有自己的坐标，x表示横坐标，y表示竖坐标。原点(0, 0)位于图像左上角，x轴的正向是原点向右，y轴的正向是原点向下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）绘制路径&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;beginPath方法表示开始绘制路径，moveTo(x, y)方法设置线段的起点，lineTo(x, y)方法设置线段的终点，stroke方法用来给透明的线段着色。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.beginPath(); // 开始路径绘制
ctx.moveTo(20, 20); // 设置路径起点
ctx.lineTo(200, 20); // 绘制一条到200, 20的直线
ctx.lineWidth = 1.0; // 设置线宽
ctx.strokeStyle = &quot;#CC0000&quot;; // 设置线的颜色
ctx.stroke(); // 进行线的着色，这时整条线才变得可见

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）绘制矩形&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fillRect(x, y, width, height)方法用来绘制矩形，它的四个参数分别为矩形左上角顶点的x坐标、y坐标，以及矩形的宽和高。fillStyle属性用来设置矩形的填充色。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.fillStyle = 'yellow';
ctx.fillRect(50, 50, 200, 100);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;strokeRect方法与fillRect类似，用来绘制空心矩形。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.strokeRect(10,10,200,100);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clearRect方法用来清除某个矩形区域的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.clearRect(100,50,50,50);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（3）绘制文本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fillText(string, x, y) 用来绘制文本，它的三个参数分别为文本内容、起点的x坐标、y坐标。使用之前，需用font设置字体、大小、样式（写法类似与CSS的font属性）。与此类似的还有strokeText方法，用来添加空心字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
// 设置字体
ctx.font = &quot;Bold 20px Arial&quot;;
// 设置对齐方式
ctx.textAlign = &quot;left&quot;;
// 设置填充颜色
ctx.fillStyle = &quot;#008600&quot;;
// 设置字体内容，以及在画布上的位置
ctx.fillText(&quot;Hello!&quot;, 10, 50);
// 绘制空心字
ctx.strokeText(&quot;Hello!&quot;, 10, 100);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fillText方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次fillText方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）绘制圆形和扇形&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;arc方法用来绘制扇形。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arc方法的x和y参数是圆心坐标，radius是半径，startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）。&lt;/p&gt;

&lt;p&gt;下面是如何绘制实心的圆形。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.beginPath();
ctx.arc(60, 60, 50, 0, Math.PI*2, true);
ctx.fillStyle = &quot;#000000&quot;;
ctx.fill();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绘制空心圆形的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.beginPath();
ctx.arc(60, 60, 50, 0, Math.PI*2, true);
ctx.lineWidth = 1.0;
ctx.strokeStyle = &quot;#000&quot;;
ctx.stroke();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（5）设置渐变色&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;createLinearGradient方法用来设置渐变色。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var myGradient = ctx.createLinearGradient(0, 0, 0, 160);

myGradient.addColorStop(0, &quot;#BABABA&quot;);

myGradient.addColorStop(1, &quot;#636363&quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;createLinearGradient方法的参数是(x1, y1, x2, y2)，其中x1和y1是起点坐标，x2和y2是终点坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。&lt;/p&gt;

&lt;p&gt;使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.fillStyle = myGradient;
ctx.fillRect(10,10,200,100);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（6）设置阴影&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一系列与阴影相关的方法，可以用来设置阴影。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.shadowOffsetX = 10; // 设置水平位移
ctx.shadowOffsetY = 10; // 设置垂直位移
ctx.shadowBlur = 5; // 设置模糊度
ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;; // 设置阴影颜色

ctx.fillStyle = &quot;#CC0000&quot;;
ctx.fillRect(10,10,200,100);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;图像处理方法&quot;&gt;图像处理方法&lt;/h2&gt;

&lt;h3 id=&quot;drawimage方法&quot;&gt;drawImage方法&lt;/h3&gt;

&lt;p&gt;canvas允许将图像文件插入画布，做法是读取图片后，使用drawImage方法在画布内进行重绘。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var img = new Image();

img.src = &quot;image.png&quot;;

ctx.drawImage(img, 0, 0); // 设置对应的图像对象，以及它在画布上的位置

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于图像的载入需要时间，drawImage方法只能在图像完全载入后才能调用，因此上面的代码需要改写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var image = new Image();

image.onload = function() {

	if (image.width != canvas.width)
        canvas.width = image.width;
    if (image.height != canvas.height)
        canvas.height = image.height;

	ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(image, 0, 0);

}

image.src = &quot;image.png&quot;;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;drawImage()方法接受三个参数，第一个参数是图像文件的DOM元素（即img标签），第二个和第三个参数是图像左上角在Canvas元素中的坐标，上例中的（0, 0）就表示将图像左上角放置在Canvas元素的左上角。&lt;/p&gt;

&lt;h3 id=&quot;getimagedata方法putimagedata方法&quot;&gt;getImageData方法，putImageData方法&lt;/h3&gt;

&lt;p&gt;getImageData方法可以用来读取Canvas的内容，返回一个对象，包含了每个像素的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;imageData对象有一个data属性，它的值是一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用putImageData方法将数组内容重新回Canvas。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
context.putImageData(imageData, 0, 0);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;todataurl方法&quot;&gt;toDataURL方法&lt;/h3&gt;

&lt;p&gt;对图像数据做出修改以后，可以使用toDataURL方法，将Canvas数据重新转化成一般的图像文件形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function convertCanvasToImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL(&quot;image/png&quot;);
  return image;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将Canvas数据，转化成PNG data URI。&lt;/p&gt;

&lt;h3 id=&quot;save方法restore方法&quot;&gt;save方法，restore方法&lt;/h3&gt;

&lt;p&gt;save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
ctx.save();

ctx.shadowOffsetX = 10;
ctx.shadowOffsetY = 10;
ctx.shadowBlur = 5;
ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;;

ctx.fillStyle = &quot;#CC0000&quot;;
ctx.fillRect(10,10,150,100);

ctx.restore();

ctx.fillStyle = &quot;#000000&quot;;
ctx.fillRect(180,10,150,100);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码先用save方法，保存了当前设置，然后绘制了一个有阴影的矩形。接着，使用restore方法，恢复了保存前的设置，绘制了一个没有阴影的矩形。&lt;/p&gt;

&lt;h2 id=&quot;像素处理&quot;&gt;像素处理&lt;/h2&gt;

&lt;p&gt;通过getImageData方法和putImageData方法，可以处理每个像素，进而操作图像内容。&lt;/p&gt;

&lt;p&gt;假定filter是一个处理像素的函数，那么整个对Canvas的处理流程，可以用下面的代码表示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
if (canvas.width &amp;gt; 0 &amp;amp;&amp;amp; canvas.height &amp;gt; 0) {

	var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

    filter(imageData);

    context.putImageData(imageData, 0, 0);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是几种常见的处理方法。&lt;/p&gt;

&lt;h3 id=&quot;灰度效果&quot;&gt;灰度效果&lt;/h3&gt;

&lt;p&gt;灰度图（grayscale）就是取红、绿、蓝三个像素值的算术平均值，这实际上将图像转成了黑白形式。假定d[i]是像素数组中一个象素的红色值，则d[i+1]为绿色值，d[i+2]为蓝色值，d[i+3]就是alpha通道值。转成灰度的算法，就是将红、绿、蓝三个值相加后除以3，再将结果写回数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
grayscale = function (pixels) {

	var d = pixels.data;

    for (var i = 0; i &amp;lt; d.length; i += 4) {
      var r = d[i];
      var g = d[i + 1];
      var b = d[i + 2];
      d[i] = d[i + 1] = d[i + 2] = (r+g+b)/3;
    }

    return pixels;

};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;复古效果&quot;&gt;复古效果&lt;/h3&gt;

&lt;p&gt;复古效果（sepia）则是将红、绿、蓝三个像素，分别取这三个值的某种加权平均值，使得图像有一种古旧的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
sepia = function (pixels) {

    var d = pixels.data;

    for (var i = 0; i &amp;lt; d.length; i += 4) {
      var r = d[i];
      var g = d[i + 1];
      var b = d[i + 2];
      d[i]     = (r * 0.393)+(g * 0.769)+(b * 0.189); // red
      d[i + 1] = (r * 0.349)+(g * 0.686)+(b * 0.168); // green
      d[i + 2] = (r * 0.272)+(g * 0.534)+(b * 0.131); // blue
    }

    return pixels;

};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;红色蒙版效果&quot;&gt;红色蒙版效果&lt;/h3&gt;

&lt;p&gt;红色蒙版指的是，让图像呈现一种偏红的效果。算法是将红色通道设为红、绿、蓝三个值的平均值，而将绿色通道和蓝色通道都设为0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
red = function (pixels) {

    var d = pixels.data;

    for (var i = 0; i &amp;lt; d.length; i += 4) {
      var r = d[i];
      var g = d[i + 1];
      var b = d[i + 2];
      d[i] = (r+g+b)/3;        // 红色通道取平均值
      d[i + 1] = d[i + 2] = 0; // 绿色通道和蓝色通道都设为0
    }

    return pixels;

};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;亮度效果&quot;&gt;亮度效果&lt;/h3&gt;

&lt;p&gt;亮度效果（brightness）是指让图像变得更亮或更暗。算法将红色通道、绿色通道、蓝色通道，同时加上一个正值或负值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
brightness = function (pixels, delta) {

    var d = pixels.data;

    for (var i = 0; i &amp;lt; d.length; i += 4) {
          d[i] += delta;     // red
          d[i + 1] += delta; // green
          d[i + 2] += delta; // blue
    }

	return pixels;

};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;反转效果&quot;&gt;反转效果&lt;/h3&gt;

&lt;p&gt;反转效果（invert）是指图片呈现一种色彩颠倒的效果。算法为红、绿、蓝通道都取各自的相反值（255-原值）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
invert = function (pixels) {

	var d = pixels.data;

	for (var i = 0; i &amp;lt; d.length; i += 4) {
		d[i] = 255 - d[i];
		d[i+1] = 255 - d[i + 1];
		d[i+2] = 255 - d[i + 2];
	}

	return pixels;

};

&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Fri, 11 Apr 2014 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/04/11/Canvas_API</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/04/11/Canvas_API</guid>
			</item>

			<item>
				<title>JavaScript 的HTML转义方法</title>
				<description>&lt;p&gt;此方法用来将用户输入内容中的尖括号、引号等进行转义&lt;/p&gt;

&lt;p&gt;正常版，可在nodejs中使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function html_encode(str) {

    var s = &quot;&quot;;

    if (str.length == 0) return &quot;&quot;;

    s = str.replace(/&amp;amp;/g, &quot;&amp;amp;gt;&quot;);

    s = s.replace(/&amp;lt;/g, &quot;&amp;amp;lt;&quot;);

    s = s.replace(/&amp;gt;/g, &quot;&amp;amp;gt;&quot;);

    s = s.replace(/ /g, &quot;&amp;amp;nbsp;&quot;);

    s = s.replace(/\'/g, &quot;&amp;amp;#39;&quot;);

    s = s.replace(/\&quot;/g, &quot;&amp;amp;quot;&quot;);

    s = s.replace(/\n/g, &quot;&amp;lt;br&amp;gt;&quot;);

    return s;
}

function html_decode(str) {

    var s = &quot;&quot;;

    if (str.length == 0) return &quot;&quot;;

    s = str.replace(/&amp;amp;gt;/g, &quot;&amp;amp;&quot;);

    s = s.replace(/&amp;amp;lt;/g, &quot;&amp;lt;&quot;);

    s = s.replace(/&amp;amp;gt;/g, &quot;&amp;gt;&quot;);

    s = s.replace(/&amp;amp;nbsp;/g, &quot; &quot;);

    s = s.replace(/&amp;amp;#39;/g, &quot;\'&quot;);

    s = s.replace(/&amp;amp;quot;/g, &quot;\&quot;&quot;);

    s = s.replace(/&amp;lt;br&amp;gt;/g, &quot;\n&quot;);

    return s;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;巧妙版：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
function htmlEncode(str) {

    var div = document.createElement(&quot;div&quot;);

    div.appendChild(document.createTextNode(str));

    return div.innerHTML;

}

function htmlDecode(str) {

    var div = document.createElement(&quot;div&quot;);

    div.innerHTML = str;

    return div.innerHTML;

}


&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Tue, 21 Jan 2014 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/01/21/html-zhuanyi</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/01/21/html-zhuanyi</guid>
			</item>
		
			<item>
				<title>IE下iframe跨域session丢失问题和解决</title>
				<description>&lt;p&gt;今天碰到一个问题，就是在IE下，使用iFrame嵌入页面时，该页面的会话级别的cookie无法写入，导致服务端始终无法获取JSESSIONID，每次都是产生一个新的，使得Session无法使用。&lt;/p&gt;

&lt;p&gt;通过网上大量的搜索发现原来IE的iframe有特殊之处, 默认情况下, IE如果发现iframe的域和父页面的域不同, 则会禁止iframe页面写入Cookie(Session在默认情况下就是通过Cookie保存一个SessionID的)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2014-1-9/1.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果将IE设置-&amp;gt;隐私的级别调至最低, 也就是接受任何Cookie, 那么是运行正常的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2014-1-9/2.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你按照上面操作并且你的问题解决了说明确定是IE这个特性导致的。
接下来我们将解决这问题。&lt;/p&gt;

&lt;p&gt;问题怎么出现的呢也许你会好奇。&lt;/p&gt;

&lt;p&gt;原因是&lt;strong&gt;&lt;em&gt;P3P&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从本质上来说，P3P 策略是由一系列多选项问题的答案组成的，因此，它并不总像一个人类可读的隐私策略那样包含许多信息细节（例如，用英语或者其他某种口语语言写成的策略是用来让人阅读的,而不是让计算机识别的）。P3P策略的标准格式使它便于自动处理。同 样 ，P3P规范也包含有用于请求和传输P3P策略的协议.P3P协议所基于的HTTP协议与 Web 浏览器用来与 Web服务器进行通信的 HTTP 协议相同。如图 1-1 所示，P3P 的用户代理使用标准的 HTTP 请求从 Web 站点上一个众所周知的地方获取 P3P 策略引用文件，并发送给发出请求的用户。这个策略引用文件指出了Web站点上各个部分所应用的P3P策略文件的位置。整个站点有可能只应用了一种策略，也可能是网站的不同部分分别应用了几种策略。这样用户代理就可以根据用户的选择来获取合适的策略，将其解析出来并采取相应的动作&lt;/p&gt;

&lt;p&gt;P3P 也允许站点在其他位置放置策略引用文件。在这些情况下，站点在声明策略引用文件的位置时，必须使用一个特定的 HTTP 报头，或者在应用了 P3P 策略的html 文件内嵌入一个 link 标 记 。
不论在何时设置cookie都可以用特定的HTTP报头来传送一个可选的 P3P 简洁策略.简洁策略是完整 P3P 策略的一个短小摘要，仅描述了与cooki e 相关的数据处理方式，并且不需要P3P 策略的完整的表达性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何使Web站点支持P3P:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从技术角度看，使 Web站点支持 P3P 是一个很容易的过程。但是，它要求网络运营商在审视数据处理方式时比以前更加仔细，并要求他们协调域内各个主机上的策略和处理方式。以下是如何使站点支持P3P 技术的具体步骤。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个隐私策略。&lt;/li&gt;
  &lt;li&gt;分析 cookie 的使用情况以及您的站点上的第三方内容。&lt;/li&gt;
  &lt;li&gt;确定要对整个站点应用一个P3P策略还是对站点的不同部分应用不同的P3P 策略。&lt;/li&gt;
  &lt;li&gt;为站点创建一个或几个 P3P 策略。&lt;/li&gt;
  &lt;li&gt;为站点创建一个策略引用文件。&lt;/li&gt;
  &lt;li&gt;为 P3P 配置服务器。&lt;/li&gt;
  &lt;li&gt;测试站点，以确定它确实支持 P3P。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大多数支持P3P的Web站点会在每台服务器上放置一个P3P策略引用文件，同时它还会在中央服务器上放置一个或多个P3P策略。这些站点也会将自己的服务器配置为用户在设置 cookie 时发送 P3P 的简洁策略。P3P 策略包括以下信息：&lt;/p&gt;

&lt;p&gt;● 如何与拥有该站点的公司、组织或个人进行联系的信息。&lt;/p&gt;

&lt;p&gt;● 用户是否可以查找该站点的数据库中保存了自己的哪些个人信息。&lt;/p&gt;

&lt;p&gt;● 如何解决与站点之间有关隐私的纠纷（如客户服务台、隐私封印以及与隐私相关的法律等）。&lt;/p&gt;

&lt;p&gt;● 所收集数据的种类。&lt;/p&gt;

&lt;p&gt;● 所收集数据的使用方式，以及用户是否能选择接受或拒绝这些用途。&lt;/p&gt;

&lt;p&gt;● 信息是否会被共享以及何时被共享，用户是否有选择的权力。&lt;/p&gt;

&lt;p&gt;● 对所收集的用户信息进行定期清除的策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP Response Header :&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考资源:&lt;a href=&quot;http://www.w3.org/2002/04/P3Pv1-header.html&quot;&gt;http://www.w3.org/2002/04/P3Pv1-header.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Compact Policies(简洁策略)&lt;/p&gt;

&lt;p&gt;简洁策略,本质上就是P3P策略的一个摘要. 他们的作用是,使用户代理,可以快速敏捷的获取到站点的P3P策略信息,所以是对性能有益的.&lt;/p&gt;

&lt;p&gt;我们常用的简洁策略的 P3P头为 -   P3P : CP=CAO PSA OUR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结下浏览器支持情况：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2014-1-9/3.png&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然知道这么多了，我们来解决问题吧。
以PHP为例子
解决这些问题，归根结底只需要一条语句设置一下header，在PHP中，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;
header('P3P: CP=&quot;CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR&quot;');

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS:如果是使用session的话，这条语句请使用在session_start();之前，如果是使用cookie，请在setcookie之前设置header。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然，比较容易想到。另外的解决办法就是在URL中加入sessionid。对此就不举例了。&lt;/p&gt;
</description>
				<pubDate>Thu, 09 Jan 2014 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/01/09/IE-iframe-P3P</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2014/01/09/IE-iframe-P3P</guid>
			</item>
		
			<item>
				<title>JavaScript 跨域访问的问题和解决过程</title>
				<description>&lt;p&gt;分享一下最近用jQuery跨域请求的经历，希望能给大家一些关于这个方案的概念和资料。&lt;/p&gt;

&lt;p&gt;1.代码很简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
$.ajax({
	url: 'http://www.tetequ.com',
	type: 'GET'
}).done(function() {
	console.log(&quot;success&quot;);
}).fail(function() {
	console.log(&quot;error&quot;);
}).always(function() {
	console.log(&quot;complete&quot;);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上去运行一下……
当然不能用!什么都还没做呢，就想做跨域访问这么危险的事情,嘿嘿！&lt;/p&gt;

&lt;p&gt;下面是Chrome给出的错误提示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-12-25/1.png&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.在服务器端做点手脚(php为例)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;
header(&quot;Access-Control-Allow-Origin:*&quot;);// 可以设置为详细的地址


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.好了现在Chrome中的Get已经可以运行了。&lt;/p&gt;

&lt;p&gt;4.还有问题。。。。忽然发现在IE8和IE9中无法运行，而在其他的浏览器中都正常（opera未测试，google说这个浏览器也有问题。不过这东西比较小众）
使用Fiddler发现 这个动作根本没有被提交到服务器端。。。。
这是多么痛的领悟啊。（IE 为什么每次你都这么另类！，jQuery你为什么不兼容ie8和ie9的跨域提交功能。。加点代码很麻烦么！！！）&lt;/p&gt;

&lt;p&gt;最后用各种方法知道了—&lt;/p&gt;

&lt;p&gt;IE8以上的版本跨域提交需要使用XDomainRequest 对象。。。。关于 XDomainRequest 请在这里查看详细，&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/cc288060(VS.85).aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/cc288060(VS.85).aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解决代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var xdr = new XDomainRequest();
        xdr.onload = function (e) {
            var data = $.parseJSON(xdr.responseText);
            if (data == null || typeof (data) == 'undefined') {
                data = $.parseJSON(data.firstChild.textContent);
            }
            //success
        };
        xdr.onerror = function (e) {
            //error
        }
        xdr.open(&quot;GET&quot;, url);
        xdr.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.问题算是解决了get都可以了。还有问题IE11你又出来干嘛了。。。你居然没有XDomainRequest。多么坑爹啊。还好IE11可以用标准的提交跨域。只是判别的时候有点蛋疼。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
navigator.userAgent.toLowerCase().match(/(msie\s|trident.*rv:)([\w.]+)/)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个能否判断IE11自己试着办哈。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;本人水平有限，如果有所遗漏和谬误，请各位朋友指正，希望一起讨论学习和进步&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
				<pubDate>Tue, 26 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/11/26/cross-domian</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/11/26/cross-domian</guid>
			</item>
		
			<item>
				<title>当下网页设计趋势</title>
				<description>&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-11-11/1.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;当下网页设计趋势&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在过去的一年中，我们都看到了网页设计趋势在日益增长。或许有些朋友还记得我早些时候的一些文章关于网页设计，在今天这篇文章中，我只是对网页设计的全新趋势走向简单的分析下。这只是本人对当下网页设计做出的一些小总结。希望这样的归类总结能给你带来更多的思路和想法。(点击图片可直接跳转至相关网页)&lt;/p&gt;

&lt;p&gt;###1.响应式网页设计（Responsive Web Design）###&lt;/p&gt;

&lt;p&gt;响应式设计已经变成了一个最终来使设计的布局适配各种数字媒体视窗的入口。此想法是用来支持所有的来自笔记本电脑，台式机，智能手机，平板和任何将来将要发布的设备。
除了多终端的多样化，我们还可以看到我们的电脑屏幕，手机屏幕都在不断变大，而在对未来生活的预测、概念设计里，“屏幕”这个产物更是被运用到多种新平台上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.tetequ.com/member/index&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/3.jpg&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;特特区&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你应该想象这个趋势更像是一份单一的代码，完美地运行在所有环境下统一网页的设计中。响应式站点被经常想象为是向手机浏览器迎合，但那不是唯一的目的。你也可以拥有一个让浏览器窗口更大，可以让你的页面布局添加鲜艳的插图和图案的响应式站点。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.tetequ.com/member/index&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/2.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;特特区&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###2.固定的头部条目###&lt;/p&gt;

&lt;p&gt;使用CSS position:fixed属性是使你的头部条目固定在网站最好的方法。当用户往下滚动你网页的时候，此方法会提供一个静止不动的导航和一个回主页的路径。这个趋势已经有一段时间，但是我们现在才看到它全部的力量。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.tetequ.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/4.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;特特区&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因为他们几乎可以工作在任何网站，所以看上去很有趣。它们包括社交网络、博客甚至有设计工作室又或者是私人公司。这种设计非常的流行并且看上去和许多布局很搭配。但是从美学角度看，这个固定的条目提供了一个减小操作网站距离感的特别用户体验。&lt;/p&gt;

&lt;p&gt;###3.大图片背景###&lt;/p&gt;

&lt;p&gt;摄影师或者摄影爱好者肯定很享受这种设计趋势。我已看过无数的案例来讨论使用超大图片来作为背景的这种想法。这是获取用户注意力极佳的方法并且当恰如其分的完成时会看上去很棒。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://im.qq.com/macqq/index.shtml&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/6.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;QQ for mac&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当大图赏心悦目的时候我就慢慢的喜欢上了它们，当你把这种大图做背景的想法融合进你的设计的时候，这样的设计技术，在市场上会使你的网站显得更专业。再如&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://qzone.qq.com/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/7.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;QQ空间&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###4.无限滚动###&lt;/p&gt;

&lt;p&gt;无限滚动加载至少存在许多年了,但是此技术直到今年才成为主流，我想在2013年还会继续。最简单的是chrome商店&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/category/apps?utm_source=chrome-ntp-icon&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/8.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;chrome商店&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是一个极好的技术，可是并不能应用在每一个布局上。但是对于能适应此方法的网站从视觉和表现上都相当惊人。&lt;/p&gt;

&lt;p&gt;###5.移动导航切换###&lt;/p&gt;

&lt;p&gt;当谈到响应式设计时，最难的问题之一是如何创建一个靠谱的导航。你希望能给用户对你所有重要的链接以直接的访问，而不要淹没在页面中而使其难以辨读。先保持导航隐藏当需要时再出现也是一个很好的点子。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.tetequ.com/member/index&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/9.jpg&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;特特区&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我所喜欢的导航切换是你可以以多种方式设计导航，你可以有从头部到底部的导航或者往下滑动，又或者左右推动内容。设计师有许多玩的选择但是对于UI实验需要更多的时间。&lt;/p&gt;

&lt;p&gt;###6.单页面网页设计###&lt;/p&gt;

&lt;p&gt;单页面设计是一个很大的话题，覆盖了许多不同网站分类。显而易见自从万维网创建单页面网站就出现了。但是最近几年这种趋势变成了一种更加自然的用户体验。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dlmu.net&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/10.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;启航计算机协会&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###7.滚动侦测网页设计（Scrollspy）###
利用CSS的实现将导航栏固定在网页顶部（大多数是顶部，当然也有侧面或底部），并将版面内容按照导航顺序垂直或横向排布，使得用户点击相应导航tab时页面自动滑到相应页面，而若点击内容，导航也将随之改变。这样的网页设计页面基本不会跳转，每一个tab所指向的页面内容也基本一屏显示完整，所以在页面呈现的内容上会有所局限。为不影响布局一般也会伴随自适应。&lt;/p&gt;

&lt;p&gt;　　
滚动侦测式的网页会给设计师带来了很大挑战——要在有限空间内保证内容呈现的完整性，故设计师会在版面上下足功夫。而这类网站结构和视差设计有异曲同工之处，所以我们发现很多网站会结合两者，给观者带来不一样的视觉感受和用户体验。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dlmu.net&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/11.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;启航计算机协会&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###8.视差滚动设计（Parallax Design）###
视差设计可以说是近年来网页设计中的一大突破，也备受推崇。视差滚动是让多层背景以不同速度滚动，以形成一种3D立体的运动效果，给观者带来一种独特的视觉感受。&lt;/p&gt;

&lt;p&gt;除此以外，鼠标滚轮的流畅体验，让用户在观看此类网站时有一种控制感，简单来说这是有响应的交互体验。就好像童年看到走马灯，转动它你就能看到人物动起来，还能欣赏故事。视差滚动设计的趣味也在于此。所以无论是网站还是电商商品宣传页都经常采用视差设计，吸引眼球也很受用户喜爱。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://graphicnovel-hybrid4.peugeot.com/start.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/13.jpg&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;Ben the Bodyguard&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://everylastdrop.co.uk/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/12.jpg&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;every Day&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###9.扁平化设计（Flat Design）###&lt;/p&gt;

&lt;p&gt;扁平化设计可以说是去繁从简的设计美学。去掉所有装饰性的设计，可以说是对之前所推崇的拟物化设计的颠覆。&lt;/p&gt;

&lt;p&gt;我们不能妄加评论说这是好还是不好，只能说它提供了一种新的设计思维。扁平化设计是否会成为将来的趋势我们也无法回答，尽管褒贬不一，备受争议，但是就现在来说它是当下的一种潮流。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://windows.microsoft.com/zh-cn/windows-8/meet&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/14.png&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;win8&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.triplagent.com/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/blog-assets/2013-11-11/15.jpg&quot; alt=&quot;当下网页设计趋势&quot; title=&quot;TriplAgent&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当创建数字产品时，用户界面是最复杂的话题。尝试着使导航和内容样式获得成功的用户体验。这些设计趋势目的是给设计师指明正确的方向。虽然设计师和开发者都需要和市场接轨并跟上潮流的脚步，但是所谓的潮流是当下的，未来确是未知的。我们的确需要保证自己不被行业趋势甩到队尾，但更重要的是在浪潮中适应和学习。&lt;/p&gt;

&lt;p&gt;相信以上的这些设计方法会流行相当长的一段时间，当然，你也可以发挥创造力，有机地组合它们，做出优秀的网站。&lt;/p&gt;
</description>
				<pubDate>Mon, 11 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/2013/11/11/qushi</link>
				<guid isPermaLink="true">http://ssy.me/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/2013/11/11/qushi</guid>
			</item>
		
			<item>
				<title>javascript 小技巧</title>
				<description>&lt;p&gt;&lt;strong&gt;字符串逆序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var reverse=function(str){
    str.split(&quot;&quot;).reverse().join('');
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;去掉前后空格&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var trim=function(arr){
    return arr.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;数组复制&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var copy=function(arr){
    return arr.slice(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;将伪数组转化为数组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var makeArray = function(obj){
    return Array.prototype.slice.call(obj,0);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Thu, 07 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/11/07/javascript-tip</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/11/07/javascript-tip</guid>
			</item>
		
			<item>
				<title>31 种 CSS 选择器用法</title>
				<description>&lt;h3 id=&quot;1&quot;&gt;1.*&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;* {
  margin: 0;
  padding: 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;星号选择器用于选取页面中的所有元素，可用于快速清除所有元素的 margin 与 padding，但最好只在测试的时候使用，而不要正式用在 CSS 文件中，否则会大大加重浏览器负担。此外，星号选择器也可以给父层的所有子元素设定样式，重复一遍，尽量少用这种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;#container * {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. #X&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;#container {
  width: 960px;
  margin: auto;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;id 选择器，最常见的选择器用法之一，不可重复使用。&lt;/p&gt;

&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. .X&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.error {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class 选择器，也是最常见的选择器用法之一，与 id 选择器不同的是 class 选择器可同时选取多个元素，而 id 选择器只能给一个独一无二的元素设定样式。&lt;/p&gt;

&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. X Y&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;li a {
  text-decoration: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后代选择器 (descendant selector)，选取 X 元素内的所有 Y 元素，比如上面这段代码将选取 li 标签内的所有链接。&lt;/p&gt;

&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. X&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a {
    color: red;
 }
ul {
    margin-left: 0;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标签选择器 (type selector)，用于选取 HTML 标签 (tag)。&lt;/p&gt;

&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. X:visited and X:link&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a:link { color: red; }
a:visted { color: purple; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:link 伪类选择器 (pseudo class selector) 用于选取所有未点击过的链接，而 :visited 则用于选取所有已访问过的链接。&lt;/p&gt;

&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. X + Y&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul + p {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;临近选择器 (adjacent selector)，选取紧邻在 X 元素后面出现的第一个元素，比如上面这段代码将选取 ul 元素后出现的第一个元素，也就是 p 元素。&lt;/p&gt;

&lt;p&gt;兼容性 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. X &amp;gt; Y&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;div#container &amp;gt; ul {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在第 4 条中，后代选择器 X Y 选取父层 X 内的所有 Y 元素；子选择器 X &amp;gt; Y 则只选取直接出现在父层 X 内的 Y 元素。比如下面的 HTML 结构中，#container &amp;gt; ul 选取直接出现在 div#container 内的 ul 元素，不包含嵌套在 li 内的 ul 元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;container&quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt; List Item
      &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt; Child &amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt; List Item &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt; List Item &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt; List Item &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. X ~ Y&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul ~ p {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样也是临近选择器，前面第 7 条 X + Y 选取紧邻在 X 后出现的第一个元素，而 X ~ Y 将选取 X 元素后出现的所有同级元素。上面这段代码将选取 ul 元素后出现的所有同级 p 元素，而不是像 ul + p 这样选取第一个出现的 p 元素。&lt;/p&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. X[title]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[title] {
  color: green;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;属性选择器 (attributes selector)，根据元素使用的属性进一步缩小选取范围，上面这段代码将选取所有使用了 title 属性的链接，或者 a[title=”title content”]{color:green} 再进一步缩小选取范围。&lt;/p&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11. X[href=”foo”]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[href=&quot;http://net.tutsplus.com&quot;] {
  color: #1f6053; /* nettuts green */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这段代码将选取所有跳转到 http://net.tutsplus.com 的链接，这些链接将显示为绿色，其他链接不受影响。&lt;/p&gt;

&lt;p&gt;只是这种方式很严格不能相差一个字符，下面将会逐一介绍更灵活的用法。&lt;/p&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12. X[href*=”nettuts”]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[href*=&quot;tuts&quot;] {
  color: #1f6053; /* nettuts green */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;表示只要属性值中包含双引号内的内容就满足选取要求，这段代码将选取跳转到 nettuts.com，net.tutsplus.com，或者 tutsplus.com 等链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13. X[href^=”http”]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[href^=&quot;http&quot;] {
  background: url(path/to/external/icon.png) no-repeat;
  padding-left: 10px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;^ 表示只要属性值以双引号内的内容开头就满足选取要求，这段代码也常用来给页面中所有外部接设定样式。&lt;/p&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14. X[href$=”.jpg”]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[href$=&quot;.jpg&quot;] {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ 表示只要属性值以双引号内的内容结尾就满足选取要求，这段代码将选取所有跳转到 jpg 图片的链接。&lt;/p&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15. X[data-*=”foo”]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面第 14 条提到了如何选取所有跳转到 jpg 图片的链接，若要选取跳转到图片的所有链接可以用下面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[href$=&quot;.jpg&quot;],
a[href$=&quot;.jpeg&quot;],
a[href$=&quot;.png&quot;],
a[href$=&quot;.gif&quot;] {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，先给图片链接添加 data- 属性（注：HTML5 Custom Data Attributes）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;path/to/image.jpg&quot; data-filetype=&quot;image&quot;&amp;gt; Image Link &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再通过属性选择器选取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[data-filetype=&quot;image&quot;] {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16. X[foo~=”bar”]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a[data-info~=&quot;external&quot;] {
  color: red;
}
a[data-info~=&quot;image&quot;] {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果属性值中有用空格分隔的一连串属性值，~ 可以选取其中一个属性值，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;path/to/image.jpg&quot; data-info=&quot;external image&quot;&amp;gt; Click Me, Fool &amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;借助 ~ 选取包含 external 或者 image 属性值的元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* Target data-info attr that contains the value &quot;external&quot; */
a[data-info~=&quot;external&quot;] {
  color: red;
}
/* And which contain the value &quot;image&quot; */
a[data-info~=&quot;image&quot;] {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17. X:checked&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;input[type=radio]:checked {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:checked 伪类选择器用于选取所有标记为 checked 的元素，比如单选框 (radio button) 或复选框 (checkbox)。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18. X:after&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;:before 与 :after 是两个令人兴奋的伪类选择器，几乎每天都有人发明出一些新用法，这里简单介绍一下如何用它清除浮动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.clearfix:after {
  content: &quot;&quot;;
  display: block;
  clear: both;
  visibility: hidden;
  font-size: 0;
  height: 0;
}
.clearfix {
  *display: inline-block;
  _height: 1%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式通过 :after 在元素后面添加一块区域，然后将其隐藏，可以弥补 overflow: hidden; 的缺陷。&lt;/p&gt;

&lt;p&gt;根据 CSS3 选择器标准，理论上伪类选择器应该使用双冒号，但实际上浏览器也支持单冒号的形式，所以可以继续使用单冒号。&lt;/p&gt;

&lt;p&gt;兼容 IE8+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19. X:hover&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;div:hover {
  background: #e3e3e3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最常用的伪类选择器，不多解释了，只是需要注意 IE6 不支持将 :hover 作用于除 a 链接外的其他元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a:hover {
 border-bottom: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外提醒一点：border-bottom: 1px solid black; 的效果要比 text-decoration: underline; 好看一些。&lt;/p&gt;

&lt;p&gt;兼容 IE6+ （在 IE6 中 :hover 只能作用于链接）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20. X:not(selector)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;div:not(#container) {
  color: blue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:not 伪类选择器有时会起到很重要的作用，假设现在要选取除 #contaienr 外的所有 div 元素，就可以用上面的代码实现。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21. X::pseudoElement&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;p::first-line {
  font-weight: bold;
  font-size: 1.2em;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过伪元素（使用双冒号 ::）可以给元素的某一部分设定样式，比如第一行、或者第一个字母。需要注意的是，这只对块级元素 (block level elements) 生效。&lt;/p&gt;

&lt;p&gt;提示：伪元素 (pseudo element) 使用双冒号 ::&lt;/p&gt;

&lt;p&gt;选取段落的第一个字母&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;p::first-letter {
  float: left;
  font-size: 2em;
  font-weight: bold;
  font-family: cursive;
  padding-right: 2px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码将选取页面中所有 p 元素，然后再选取其中的第一个字母。&lt;/p&gt;

&lt;p&gt;选取段落的第一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;p::first-line {
  font-weight: bold;
  font-size: 1.2em;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与上面的例子类似，通过 ::first-line 选取页面的第一行。&lt;/p&gt;

&lt;p&gt;为了兼容 CSS1 与 CSS2 中的伪元素（比如 :first-line, :first-letter, :before 以及 :after），浏览器接受单冒号与双冒号两种格式，但对于 CSS3 中最新引入的伪元素，必须使用双冒号。&lt;/p&gt;

&lt;p&gt;兼容 IE6+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22. X:nth-child(n)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;li:nth-child(3) {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:nth-child(n) 用于选取 stack 中的某一个元素，只接受整数作参数（参数从 1 开始计数），如果你想选取第二个 li 元素，只需这样写 li:nth-child(2)。&lt;/p&gt;

&lt;p&gt;也可以设定可变的参数，比如 li:nth-child(4n) 将选取第 4, 8 , 12… 个元素（4*n, n=1, n++）。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23. X:nth-last-child(n)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;li:nth-last-child(2) {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了正序（从上往下）选择，也可以使用 :nth-last-child(n) 倒序（从下往上）选择第几个元素，其他用法与第 22 条完全一样。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24. X:nth-of-type(n)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul:nth-of-type(3) {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:nth-of-type(n) 的作用不是选取子元素 (child element)，而是选取同类元素 (type of element)。想象一下 HTML 文件中包含 5 个 ul 元素，现在要选取第三个，只需使用上面的代码，而不用再单独这个 ul 添加 id。&lt;/p&gt;

&lt;p&gt;关于 :nth-child 与 :nth-of-type 的区别，具体请查看 CSS-Tricks 网站的解释，简单来说，如果父层内只包含一种元素（比如都是 p 元素）那两种用法是等效的，如果父层包含多种元素（比如 p 元素与同级的其他元素），需要选取第几个 p 元素时应该用 :nth-of-type。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25. X:nth-last-of-type(n)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul:nth-last-of-type(3) {
  border: 1px solid black;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与第 24 条用法相同，倒序选取同类元素。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;26. X:first-child&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul li:first-child {
  border-top: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选取父层内的第一个子元素。&lt;/p&gt;

&lt;p&gt;兼容 IE7+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;27. X:last-child&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul &amp;gt; li:last-child {
  color: green;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与第 26 条用法相同，区别在于 :last-child 选取父层元素内的最后一个子元素。&lt;/p&gt;

&lt;p&gt;:first-child 与 :last-child 通常用来清除边框 (border)，比如 &amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;内每个 &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt; 都使用了 border-top 与 border-bottom 边框，结果是，第一个元素的上方与最后一个元素的下方会是单边框效果。这种情况可以用 :first-child 与 :last-child 清除上下的边框，而不用给第一个元素添加 id=”first” 或者给最后一个元素添加 id=”last”。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28. X:only-child&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;div p:only-child {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个伪类选择器不常用，它可以选取包含唯一指定子元素的父层。比如上面的代码中将选取下面第一个 div 元素，而不是第二个 div 中的 p 元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt; My paragraph here. &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt; Two paragraphs total. &amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt; Two paragraphs total. &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29. X:only-of-type&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;li:only-of-type {
  font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个选择器会选取某个元素，并且这个元素在其父层内没有其他同级同类元素（不一定是唯一元素）。比如，要选取所有只包含一个 li 元素的 ul 元素该怎么做呢？如果使用 ul li 将选取所有 li 元素，应该使用 only-of-type。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30. X:first-of-type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;first-of-type 伪类可以选取某种元素的第一个同类元素。&lt;/p&gt;

&lt;p&gt;为了更好地理解它的用法，现在思考一下如何在下面的 HTML 结构中选取 List Item 2 ？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt; My paragraph here. &amp;lt;/p&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt; List Item 1 &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt; List Item 2 &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt; List Item 3 &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt; List Item 4 &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul:first-of-type &amp;gt; li:nth-child(2) {
  font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的意思是：首先选取第一个 ul 元素；然后选取其中的所有直接子元素，也就是 li；最后选取第二个子元素。&lt;/p&gt;

&lt;p&gt;方法二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;p + ul li:last-child {
  font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到 p 元素后第一个出现的 ul 元素，然后选取其中的最后一个子元素。&lt;/p&gt;

&lt;p&gt;方法三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul:first-of-type li:nth-last-child(1) {
  font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到第一个 ul 元素，然后从上往下选取第一个子元素。&lt;/p&gt;

&lt;p&gt;兼容 IE9+&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;31. 伪类选择器叠用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有些伪类选择器或者伪元素是可以叠用的，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;#post p:nth-of-type(2):first-letter {
  float: left;
  margin: 0 5px 0 1em;
  width: 1em;
  height: 1em;
  font-size: 2em;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目测兼容 IE9+，听说 IE10 有个小 bug&lt;/p&gt;
</description>
				<pubDate>Fri, 25 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/25/31CSS</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/25/31CSS</guid>
			</item>
		
			<item>
				<title>对前端开发初学者的一些建议</title>
				<description>&lt;p&gt;其实写这篇文章只能对初学者有用，为什么那。因为我也是刚入行没到1年的新人。有的人说，前端的知识刚多少东西。改改颜色，弄弄文字大小而已。2年就已经是老鸟了。
好吧我之前也这么认为的，我不否认。但是随着项目的增加，学到更多的知识，让我感觉前端的水很深。
html5和css3的出现也在这很深的水里增添了几分神秘感。到底web以后能做什么。我想许多业内做过5-6年的是前端开发人也未必能预测出来。
言归正传，对前端开发初学者如何能在繁杂的web领域学习我自己这总结了一些经验。希望对大家有所帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1).开一个技术博客&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;技术博客不是新浪网易的blog，是独立空间独立域名并且自己建立的blog。这个blog不一定要自己写程序实现。可以用很成熟的建站工具比如：wordpress。不过要是前端的话最好可以实施jekyll这个框架，因为不涉及到后台。就是说前端真的可以脱离后台了（虽然这是臆想，不过jekyll毕竟实现了）。在建站的过程中你可以甚好的把握一下整个网站的建立过程和流程。能更清晰的了解到一个团队在做网站的各个流程和过程，对工作也很有帮助。
建立完blog当然不是没事了，开始记录你的个人学习笔记吧。&lt;/p&gt;

&lt;p&gt;收集→整理→消化→分析→应用→分享。基本上就是这么个流程。
在收集分享的过程中，会遇到很多牛人。一定要虚心向他们学习。你的学习态度往往决定了你能学习多少知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2)少聊天多动手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据我的经验，在你认识很多人后，加入一些学习群组后。会随后产生惰性和依赖性。很多问题都会问群里的朋友，甚至文字缩进这样的问题也会问。（我碰到过，开始我还耐心解答，后来问题越来越**[此处省略2个字]后来都懒得理了）如果这样立刻改掉这个习惯，打开googole搜索你的问题，然后找答案吧。甚至在别人问一些你不懂的问题的时候也自己多搜索多尝试多做。来不断的提高自己。&lt;/p&gt;

&lt;p&gt;喜欢看视频教程，电子书，下载了一堆还在那放着，从未精读过的着的前端兄弟是不是就是你。就算是看了也是看完就算，从没思考从没追问从没实践过有木有。该怎么做那？相信看我的标题也你该知道了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3)收听前端大牛的微博&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一说微博所有人都把娱乐结合到一起。但微博另一个特点是信息的更新速度和实时性。你可以在订阅中发现很多最新最好的前端技术。一个连接甚至能让你看到很多你看不到的前端世界。新浪微博-腾讯微博都可以，学习的氛围都很强。只有你想不到，没有你看不到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4）订阅前端大牛博客&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果微博是获取新知识的道路，那么博客就是新知识的目的地。真正的内容和实质都在这里。所以这也是我认为微博永远不可能取代博客的原因之一。他们俩的关系就和快餐和正餐的关系差不多。rss阅读器刚开始用还真的不太习惯。不过消息的及时性还是真不错的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5）学习html5和css3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个问题在我所在的css学习群讨论过，很多前端同学都会问。用学html5和css3吗？好像在中国这个大的浏览器环境下它们都是浮云。估计应用上都要好些年吧。学了也没用。&lt;/p&gt;

&lt;p&gt;我认为：html5和css3的使用会先在移动平台上普及。当然是智能移动平台。因为他们的浏览器都是wekit内核。有着天生的地理优势。优秀的用户体验会让用户对web应用重新点燃热情。好吧有什么前景自己看吧。&lt;/p&gt;
</description>
				<pubDate>Wed, 16 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E6%9D%82%E8%B0%88/2013/10/16/web_advice</link>
				<guid isPermaLink="true">http://ssy.me/%E6%9D%82%E8%B0%88/2013/10/16/web_advice</guid>
			</item>
		
			<item>
				<title>如何通过数据指导产品优化</title>
				<description>&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/1.png&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设计师生来就是要解决问题的。那如何才能更好、更高效地解决问题？首先要求我们能发现问题，数据分析就是一种常用的发现问题的手段。通过数据定位问题，然后用设计方案来尝试解决问题，之后再用量化的数据指标来评估问题是否解决了，解决了多少。通过迭代优化，问题就能够得到较好解决。&lt;/p&gt;

&lt;p&gt;本文结合自己在在登录产品的体验优化中积累的一些实战经验，重现过程中的设计点滴，有效果明显的方案，也有效果不明显的优化尝试，最后将总结一些通用的设计思路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;登录失败的原因在哪？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;登录框一般是个较简单的界面，它包括：账户名和登录密码、校验码、其他账户登录入口、注册等关联操作等元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/2.png&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看似一个简单的界面，每天却有不少用户尝试登录却登录失败。某些流量较大的网站，每天可能有上百万登录失败次数。登录作为用户进入一个产品的第一道门，体验非常关键。因此我们把登录成功率作为衡量登录产品体验好坏的最重要的指标。&lt;/p&gt;

&lt;p&gt;通过数据收集和分析后，我们发现用户登录出错的原因占比如下图（图中数据做了模糊处理）：登录密码出错、账户名出错、校验码出错是影响登录成功率的top3因素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/3.png&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细定位问题，各个击破&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;针对上述的top3问题，我们迭代做了优化。在此以校验码出错的优化为例，来说明优化思路。前面我们通过数据定位了大问题出在哪里，接下来我们需要详细定位问题。那校验码为什么出错？有什么解决方案？&lt;/p&gt;

&lt;p&gt;通过页面埋点点击数据和后台日志我们发现用户刷新图片校验码概念较高，平均每个用户会刷新2次校验码才能输入正确。所以问题可归纳为：校验码识别度低，容易输错。&lt;/p&gt;

&lt;p&gt;那对应有怎样的解决策略？不妨尝试下这种循序渐进的解决思路：事前、事中、事后。&lt;/p&gt;

&lt;p&gt;1）事前：我们把输入图片校验码作为一个事件，那“事前”的意思就是不出现图片校验码，或者降低校验码出现概率。图片校验码的作用是防止机器批量登录行为。逆向思考下：如果我们能保障系统安全的情况下，通过技术手段尽可能提前识别是人在请求登录，还是机器恶意登录。确信识别为人在登录的情况下，就不出现图片校验码（如下图），就可以大大减少正常用户登录时输入图片校验码的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/4.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上线后，通过跟踪登录成功率数据，发现此优化效果非常明显。&lt;/p&gt;

&lt;p&gt;2）事中：近一步发现校验码是数字和字母随时混搭出现，如数字“0”和字母“O”，数字”1”和字母“I” 很容易混淆。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/5.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决方案：降低容易混淆的数字和字母出现的概率，如果出现了数字“0”或字母“O”，默认用户输入其中一个都是正确的。条件允许的话，还可以过滤掉这些容易混淆的组合，提高用户首次输入的成功率。&lt;/p&gt;

&lt;p&gt;还有一个解决策略是用户输入校验码后即时反馈结果：输入正确还是错误。&lt;/p&gt;

&lt;p&gt;输入正确的提示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/6.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入错误的提示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/7.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个优化，用户可以提前知道自己出错了，而不需要登录请求后才知道出错了，导致一次登录失败。所以用户登录效率更高了（用时更短），而登录成功率也有不小的提升。&lt;/p&gt;

&lt;p&gt;3）事后：用户输错一次图片校验码了，再次输入如何能更容易成功？如下图中，用户通过点击图片校验码区域刷新出现另一张校验码，但相对隐晦，部分用户出错了，就不知道点击换一张校验码图片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/8.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决方案：强化刷新图片校验码的操作按钮，同时增加语音校验码。虽然语音校验码本意是为盲人用户设计的，但正常用户在图片校验码老是输错情况下，也可以使用语音校验码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-13/9.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，总结下通过数据来指导产品优化的一般流程。&lt;/p&gt;

&lt;p&gt;第一步：确定产品体验的量化指标&lt;/p&gt;

&lt;p&gt;如上面案例中我们用成功率来衡量登录产品体验好坏的指标。什么指标可以用来量化某个产品的体验呢？这是目前交互设计领域讨论比较多的话题，这里先不展开阐述，只提供参考建议：一、用户体验的改变对该指标有至关重要的影响；二、该指标很好被量化；三、清楚该指标是如何计算的，项目组达成共识，这样才能更有的放矢的开展设计。&lt;/p&gt;

&lt;p&gt;第二步：数据分析准确定位问题&lt;/p&gt;

&lt;p&gt;找到影响上述量化指标的产品问题点在哪，如上述案例中登录失败有哪些情况，占比怎样。视产品不同，数据来源可以是产品的后台日志数据，用户点击行为数据或用户来电求助率，等等。再近一步分析：密码为什么出错、账户名为什么出错、图片校验码为什么出错。比如我们通过大量的用户来电客服录音就可以找到用户密码出错的真正原因：将支付密码和登录密码混淆，跟其他产品的秘密混淆；密码设置得太复杂，记不住；密码出错后，找回密码不成功，等等。&lt;/p&gt;

&lt;p&gt;第三步：迭代优化，用数据检验效果&lt;/p&gt;

&lt;p&gt;找到了问题，就针对性得设计方案。解决思路可以参考上述的“事前”、“事中”和“事后”。事先：问题是否能提前规避，降低发生的概念；事中：问题发生了，如何帮助用户快速解决；事后：如何避免再次发生。优化方案快速上线，看对应的体验指标是否改变了，改变了多少。往往不可能一步到位就把问题解决掉，需要迭代优化，不断通过数据跟踪来修正设计策略。通过效果累计，达到我们最终的设计目标。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;转自：&lt;a href=&quot;http://ux.etao.com/posts/818&quot;&gt;阿里妈妈UED&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sun, 13 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/2013/10/13/youhua</link>
				<guid isPermaLink="true">http://ssy.me/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/2013/10/13/youhua</guid>
			</item>
		
			<item>
				<title>复杂产品的响应式设计【流程篇】</title>
				<description>&lt;p&gt;都说2013年将是响应式设计爆发的一年。一淘设计团队在去年一淘首页改版时初步尝试了响应式，最近在一淘“玩客”项目中有了更加深入地应用，第一次在复杂产品中实现了全站响应式。中间积累了一些经验也踩了不少坑，于是就有了这个响应式设计三部曲，此系列文章包含理念篇、知识篇和流程篇。&lt;/p&gt;

&lt;p&gt;响应式网页不像传统网页只需考虑一种状态，不是交付一套设计稿就完事儿了，它给设计、前端和开发团队之间的协作模式带来新的挑战。在一个复杂产品全面响应式的项目里，交互每个阶段该产出什么？交互与视觉如何协作？前端何时介入？哪些事情让后端开发来做更合理？经历“玩客”第一版后，我们得到了一些答案。&lt;/p&gt;

&lt;p&gt;响应式设计之所以叫响应式“设计”而不叫响应式“技术”，是因为它是一项设计先行的工作。需要设计先明确好响应方式再实现出来，不能出一套设计稿后等着前端看情况把它变成响应式网页。所以整个流程最初从交互阶段开始，分成6个主要步骤，视觉、前端、开发等角色根据情况尽早介入。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/1.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step1：信息架构，确定内容策略。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据产品定位和用户分析，交互设计师确定站点信息架构。（信息架构呈现方式有很多种，这不是本文重点，不详述）。&lt;/p&gt;

&lt;p&gt;这时候可以明确这个产品有多少页面，每个页面包含多少内容，内容优先级是什么。很多产品包含N多页面，每个页面一一考虑响应式设计容易造成混乱且成本巨大。所以下一步重要工作是分析页面类型把页面归类。以玩客为例，可以把10多个页面分成三类：列表类页面、详情类页面、操作类页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/2.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step2：移动框架&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先说下为什么第二步要先设计移动框架。移动优先是移动互联网浪潮下应运而生的理念，由Luke Wroblewski最早提出。移动优先并不是指移动更重要，响应式设计理念里设备是同等重要的。它是指优先设计手机端的体验，有三个原因：&lt;/p&gt;

&lt;p&gt;手机让设计专注，强迫你想清楚什么信息是最重要的。因为手机屏幕小，每屏呈现的内容少；触屏手机使用手指操作而非鼠标这样的精密设备来操作，对操作有更高要求；手机使用场景更加丰富，很多场景用户是缺乏耐心的，比如当你排队看电影正在找手机上的电子票，马上排到你了翻半天却迟迟找不到那张票这是多么令人崩溃的事情。
手机许多特性让设计更强大。手机上的语音输入、地理位置定位、丰富的手势操作、越来越多传感器，手机交互比PC拥有更多可能性。从手机开始设计，让你更早地思考如何发挥这些特性。
手机正在迅猛增长。手机即将超越PC，成为最主流的上网方式，这个趋势是不可逆的。
从移动开始做设计对习惯了PC环境的设计师可能是一种挑战，思考方式工作习惯都被迫做出改变。但这种改变必须去适应，因为用户习惯在改变。&lt;/p&gt;

&lt;p&gt;回正题，上一步已经把页面归类并确定每个页面内容优先级，现在接着分析每种类型页面的导航、主体内容等框架结构，最终得出一份框架结构表。从玩客框架结构看出，全局导航是所有页面公共的，局部导航只有列表类页面才有，详情类页面都有一个“页面主人”信息，而关联导航不是每个页面都有。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/3.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着开始设计手机端“超细长页面”的框架（因为手机上一般是单列布局，所以页面又细又长）。这一步开始把信息结构设计成最粗放的框架，可以在白板或纸面上完成。要实现的关键目标是：把这个页面最需要呈现给用户的内容放在最重要的位置，要符合手机上的阅读和操作习惯，尽量利用手机设备的特性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/4.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step3：响应式框架&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据手机端的框架拓展出平板和PC端框架。这是复杂产品实现响应式设计的关键步骤，它是让众多页面有条理地响应起来的基础。第一件事情是确定响应式模式，即从手机到平板到PC，导航怎么变化，页面布局用哪种响应方式，根据内容优先级如何调整模块顺序，等等。玩客在PC端以三栏布局为主，左边栏作为局部导航或者主人信息区，中间栏始终是页面主体信息，当页面需要关联导航时统一放在右边栏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/5.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到现在这个阶段所有页面的响应式开始有规则可循，下一步工作就是继续细化规则，把框架精确到具体尺寸。具体说来就是制定流体栅格系统。流体栅格系统是基于百分比的栅格布局工具，具体的制定方法会在另外一个篇章【知识篇】中详细介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/6.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;响应式是一种设计理念与前端技术紧密结合的新兴形态，鼓励尽早进行跨职能沟通协作。交互确定响应式框架和栅格系统后，其他角色就可以同步开展工作了。前端开始介入完成栅格和框架搭建，产出页面基础框架。视觉同步开始探索和定义视觉风格探索，制定视觉框架，产出风格关键词、产品配色方案。整个过程需要几个角色不断讨论确定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step4：模块设计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按照移动优先的原则应该先进行移动端的模块细节设计，不过我们选择了从PC端开始设计细节。因为PC端开发能够充分暴露业务复杂度，项目团队的设计、开发、测试在PC环境下拥有成熟的工具和流程，从PC开始让开发过程更顺畅。所以个人认为移动优先是确定内容策略时应该遵循的理念，细节设计和开发过程是否要移动优先，取决于产品定位和项目团队情况。&lt;/p&gt;

&lt;p&gt;响应式框架确定了页面结构和响应模式，模块设计这个过程开始完善所有信息排版和交互形式，这是交互设计师最熟练也是最耗时的工作。这个过程与传统流程没太大区别，只是心里要不断提醒自己，这个模块不是只为这个设备设计，它在其它设备下会出问题吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/7.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;交互确定页面模块细节后可以抽取出产品用到的控件、组件和公共模块，现在视觉和前端开始做一件有别于传统流程的事情。视觉根据前期定义的风格设计控组件和公共模块的视觉效果，把它们拼成一个模拟的页面，我们称之为风格拼贴稿。前端再把风格拼贴稿里的控组件和公共模块实现出来，统一维护一套组件规范代码。&lt;/p&gt;

&lt;p&gt;传统的做法往往是页面视觉定稿后设计师开始整理视觉规范标注给前端。风格拼贴稿是将这个工作尽可能提前，并变成一个设计协作利器。它的好处是：&lt;/p&gt;

&lt;p&gt;1、一个页面的视觉效果实际上是由一堆控组件和公共模块组成，用真实的控组件和公共模块拼贴的模拟页面已经可以呈现出产品的视觉风格。把一个产品10多个页面的视觉稿全部完成定稿是非常费时费力的事情，产出一份风格拼贴稿则轻松得多。所以它是一个高效的设计工具。&lt;/p&gt;

&lt;p&gt;2、复杂产品总是涉及多个设计师和前端并行工作，尽早地把控组件和公共模块抽取出来统一管理，是保证视觉风格一致性的有效方法。避免不同设计师同时设计同一个控组件或公共模块，减少重复开发造成的浪费。也大大降低后期更新和维护页面的成本，比如当需要修改“关注”按钮时只需改一个就能全站生效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/8.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step5：响应式模块设计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PC端页面模块细节和风格拼贴稿完成后，剩下工作是拓展出平板和手机端的完整设计稿，前端产出全部响应式页面代码。进行响应式模块设计时最需要关注的仍然是让操作符合设备习惯，充分利用设备特性。&lt;/p&gt;

&lt;p&gt;至此，一个全站响应式产品的页面就陆续出来了。很多人认为响应式设计维护成本高的理由是一个页面要同时设计多套设计稿。玩客这次经验告诉我们，确定一套设计稿和栅格系统后再拓展出其它设备下的设计方案，工作量远比想象中的低。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/9.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step6：测试&amp;amp;讨论&amp;amp;优化，提交开发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;离大功告成还差最后一步，在真实设备下测试页面效果，项目团队讨论并持续优化。&lt;/p&gt;

&lt;p&gt;在提交开发之前需要尽早明确服务端响应（RESS）的策略。服务端与客户端结合是目前解决响应式页面性能问题的最合理方案。哪些大图片在移动设备下只需输出小尺寸图片？哪些内容在什么设备下是不需要开发输出的？哪些可以减少输出的数据数量？与开发团队协作的响应式可以有效控制页面文件大小，避免页面成为移动设备上烧用户流量的罪魁祸首。&lt;/p&gt;

&lt;p&gt;测试通过后提交页面进入开发环节。我们从可用性和可访问性两方面总结了一份响应式页面测试checklist，测试要点包括但不限于以下内容。欢迎补充。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/10.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上流程是我们团队做完一个全站响应式项目后集体总结得出，不管你是对响应式感兴趣、正在做响应式，还是即将开始做响应式，希望对你有所帮助。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;转自:&lt;a href=&quot;http://ued.taobao.com/blog/2013/05/%E5%A4%8D%E6%9D%82%E4%BA%A7%E5%93%81%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E3%80%90%E6%B5%81%E7%A8%8B%E7%AF%87%E3%80%91/&quot;&gt;淘宝有一点博客&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/05/Responsive_Web_Design_step</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/05/Responsive_Web_Design_step</guid>
			</item>
		
			<item>
				<title>响应式网页设计</title>
				<description>&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-05/001.jpg&quot; alt=&quot;网页设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在设计中经常遇到这几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;想要网站兼容手机、平板电脑、pc，就得为不同的设备定制不同的版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;想要网站的某些页面在宽屏显示器下一行显示更多的内容，又得为宽屏定制一个版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;很多人并不是在全屏的情况下浏览我们的页面，如果让页面随着浏览器宽度改变而相应的调整会不会比较好？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有没有办法能有效解决这些问题呢？&lt;/p&gt;

&lt;p&gt;响应式网页设计是Ethan Marcotte在去年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念可以说是是为移动互联网而生的！&lt;/p&gt;

&lt;p&gt;或许大家之前会注意到，有很多知名网站都推出了iPhone或针对智能手机的专门网站，比如3g.qq.com、m.taobao.com、ipad.xxx.com等等。。。甚至前端观察之前也尝试过用wordpress插件实现m.qianduan.net的移动网站。  那么问题就来了——我们要为每一个设备做一个单独的网站吗？来让网站在每个设备中得到相应的视觉风格和操作体验？  这样势必就要增加很多的工作量，而且很多还是重复的。  我们在做页面的时候，一般很强调模块化的概念，我们要求一个合格的模块要能够“可扩展、无侵染”，它要能够用在任何地方都能够正常的显示。响应式网页设计与此类似——网站在任何设备中都能够正常适配，而不用为每个设备单独做个子网站！  但是，产品经理和设计师可能还是会要求网站在各个浏览器里面表现要一模一样，甚至要像素还原——WTF！不同的浏览器本身的功能、行为和处理方式都不一样，为什么要表现完全一样？！&lt;/p&gt;

&lt;h3 id=&quot;响应式web设计的优势&quot;&gt;响应式Web设计的优势：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;随着移动设备越来越多，可以提升用户体验。&lt;/li&gt;
  &lt;li&gt;该设计没有页版本区分，所以SEO的策略保持一致。&lt;/li&gt;
  &lt;li&gt;开发、维护、运营成本优势,页面只有一个，只是针对不同的分辨率、不同的设备环境进行了一些不同的设计，所以在开发、维护和运营上，相对多个版本，能节约成本。&lt;/li&gt;
  &lt;li&gt;Google也建议优先采用响应式设计，因为无论是什么页版本都是相同的HTML、相同的内容，Google最容易处理&lt;/li&gt;
  &lt;li&gt;兼容性优势：移动设备新的尺寸层出不穷，定制的版本通常只适用于某些规格的设备，如果新的设备分辨率变化较大，则往往不能兼容，而开发新的版本需要时间，这段时间内的访问就是个问题，但是响应式Web设计可以提前预防这个问题。&lt;/li&gt;
  &lt;li&gt;操作灵活：响应式设计是针对页面的，可以只对必要的页面进行改动，其他页面不受影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;响应式web设计的趋势&quot;&gt;响应式Web设计的趋势：&lt;/h3&gt;

&lt;p&gt;响应式设计在2012年被提的比较多，但是响应式设计仍然在不断变化，不断创新。比如，新的设备不断出来(iPad Mini)，这让以前的设计想法土崩瓦解。而各种Web的响应式设计也获得了越来越多的注意，“让人们忘记设备尺寸”的理念将更快地驱动响应式设计，所以Web设计也将迎来更多的响应式设计元素。&lt;/p&gt;

&lt;p&gt;免费轻量级的响应式 CSS 网格系统，让你可以快速创建适应于手机和平板电脑的网站。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上都是只是介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想深入学习请参考:&lt;a href=&quot;http://webdesignerwall.com/tutorials/responsive-design-with-css3-media-queries&quot;&gt;http://webdesignerwall.com/tutorials/responsive-design-with-css3-media-queries&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;相关文章、网站：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://beforweb.com/node/7&quot;&gt;通过CSS3 Media Query实现响应式Web设计&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.templatemonster.com/infographics/responsive-web-design-interactive-guide.php&quot;&gt;一个国外的响应式web设计介绍网站&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/05/Responsive_Web_Design</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/05/Responsive_Web_Design</guid>
			</item>
		
			<item>
				<title>浅谈禁用状态</title>
				<description>&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/banner.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　禁用，顾名思义，代表不可用的意思。有一个禁用，就一定对应着一个可用。不论是表单，还是复杂性管理界面，抑或是分步引导，这些场景中都有可能出现禁用状态，而如何合理运用禁用状态，让它成为体验的加分项而不是减分项，正是设计师要不断思考、深入实践的。这里抛一些砖出来，希望和大家一起探讨。&lt;/p&gt;

&lt;p&gt;　　“这个不可点的按钮放在这里很鸡肋，我们是不是可以考虑去掉？”&lt;/p&gt;

&lt;p&gt;　　“默认放出按钮吧，不能点也没关系，不然用户怎么了解产品中有哪些功能？”&lt;/p&gt;

&lt;p&gt;　　禁用状态可看为应用程序机制对外暴露的一个直接体现，什么时候展现，什么时候隐藏，也是设计中经常碰到的争议话题。&lt;/p&gt;

&lt;p&gt;　　Alan Cooper曾提到，激活和禁止菜单可以帮助用户了解菜单所反映的用途，从而帮助菜单成为更好的教学工具。例如我们常用的Photoshop选择菜单：&lt;/p&gt;

&lt;p&gt;　　菜单作为软件中最完备的功能集合，应该呈现所有的功能，这是第一个前提。在这个前提下，再根据具体交互的流程来展示哪些操作可用，哪些禁用。仔细想想，在我们日常所见的各种软件中，你并不会对菜单里的禁用项感到陌生。&lt;/p&gt;

&lt;p&gt;　　菜单有一个好基友叫做工具栏。作为一种直观、快捷的功能呈现形式，有幸出现在工具栏上的操作一般来说是软件中最常用的功能，为用户提供快速、高效的操作入口。&lt;/p&gt;

&lt;p&gt;　　工具栏给用户的预期应该是稳定的，可靠的，用户会不知不觉地对工具栏的布局进行学习，记住常用操作的位置，形成使用惯性。如果某个按钮有时消失，有时出现，用户会感到迷惑，也不利于提高界面操作的效率。尤其是当工具栏上有大量操作时，固定位置的好处显而易见，例如Ribbon界面，每个子面板下都包括至少5个以上的按钮：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/2.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　看上去，对于菜单、工具栏中的操作，不论是否有禁用状态，默认放出来是最好的选择。然而当操作较少时，设计师们仍然会做出思考和改进。&lt;/p&gt;

&lt;p&gt;　　浏览器，一个所有人都离不开的软件，前进、后退是它的核心功能之一。在这件事上，Chrome和Firefox采取了不同的设计思路。Chrome的前进、后退按钮将位置固定在地址栏左侧，根据当前网页的访问路径判断该按钮是否展示为可用状态，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/3.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/4.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　如果用户是按照开新窗口的模式打开新页面，浏览完毕就关闭窗口，前进按钮并不会出现；如果用户在同一窗口内新开页面，再点击后退时，前进按钮快速滑出，动画的衔接让它具备了功能自解释的属性，不会给用户造成理解上的困惑。当页面不能继续前进的时候，此时前进按钮瞬间变为禁用状态且快速滑动收起消失，用户也没有机会去点击。这样一来，Firefox地址栏左侧的空间在大部分情况下视觉感受轻量简洁，仅有一个最重要的后退按钮，而在需要使用前进按钮的场景下，操作也是流畅、自然的。&lt;/p&gt;

&lt;p&gt;　　这里不评判两种设计孰优孰劣，在处理前进按钮的这个问题上，Chrome和Firefox都有各自的答案。Firefox之所以采用这种较为大胆的设计，我认为和前进按钮的使用频率、使用场景有着密不可分的关系。再换个角度，Chrome也并不适用Firefox的设计：在Chrome地址栏左侧有3个按钮，如果中间的按钮有时会隐藏，那么最后一个刷新按钮的位置无法固定，在用户看来这个“工具栏”是有明显跳动存在的，而firefox的刷新按钮是在地址栏右侧，并不会有这样的问题。&lt;/p&gt;

&lt;p&gt;　　上文是一层操作的例子。那么多层操作呢？假如你面对一组信息列表，针对全部列表有一套操作，针对每条信息又都有一套新的操作时，就必须要考虑隐藏的设计了。&lt;/p&gt;

&lt;p&gt;　　Gmail的邮件列表页在未选中邮件时，工具栏只包括3个针对列表的功能。选中具体邮件后，针对该邮件的操作出现在工具栏中，原有的操作消失。这样既可以避免未选中邮件时大量禁用操作摆放在界面上给用户造成负担，又保证工具栏在默认状态下的清爽简洁。然而，这种设计也给用户带来一定的学习成本，新手用户在初次使用时需要探索一番才能明白邮件选中前后的区别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/5.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　Dropbox也采用了类似的设计，在默认界面的表格标题栏中不呈现任何操作，单击选中文件后，具体操作展现在工具栏上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/6.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当我们面临不那么复杂的操作时，例如web上的发布表单、提交流程等，对禁用状态的取舍则需要更加细致入微的思考。以下是一些设计建议供参考：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.需要应引导用户操作时，扔掉禁用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　先来看看新浪微博的发布按钮。这个按钮仅当发布框中有文字时展示为明确可点击的红色；若发布框中没有文字，按钮显示为灰色，点击时发布框背景色变红闪烁，提示用户输入内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/8.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/9.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这里设计要表达的目的很明确，既输入文字后才可以发布。然而，当发布按钮看上去呈现不可点击的灰色时，鼠标移上按钮仍然为手型，点击后系统也给出了交互上的反馈，这样一来按钮就被赋予了多重含义，在变灰时也可以点击，给用户造成了理解上的困惑。按照用户的认知，如果一个按钮看上去可点击，那么它应该实际也可点击。如果看上去不像能点的样子，那它就应该不可点。&lt;/p&gt;

&lt;p&gt;　　facebook 的状态发布按钮并没有设计禁用状态，当输入框内容为空时，点击Post按钮，页面上不会产生变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/10.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　腾讯微博的发布按钮也采用同样的设计，假如内容为空时点击按钮，在输入框的右下角会以橙色文字提示用户输入内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/11.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　对于微博或类SNS的网站，发布状态是最重要的写操作入口，按钮在界面上可以起到良好的引导作用。这种情况下，仅赋予按钮一种状态，是不是更简单、更容易理解呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.明确区分禁用和可用样式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　如果某个操作确实需要禁用状态，那么在视觉上需要明确区分可用的样式与禁用的样式。举一个反例，在tumblr发布文字时，左下角的发布按钮很难看清什么情况下是可用，什么情况下是禁用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/12.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上图中，红色圈出的部分是禁用状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/13.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上图为输入文字后的状态，左下角的Publish此时已经可点击了，但按钮的颜色、立体效果均没有改变，仅文字变亮，而文字的亮度和禁用状态下仅有细微的差别，在比较差的显示器上是无法分辨的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.在恰当的时候给出恰当的解释&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当禁用状态的变化对用户来说有些突然时，可以考虑设计清晰易懂的解释性说明。例如Bing搜索首页，当某张图片不能下载时，下载按钮置灰，当鼠标移动到按钮上时，tips解释了该按钮置灰的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/14.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　OS X的设置窗口中，Advanced按钮默认是禁用的。在这种类似的设置窗口中，OS X使用左下角的带锁开关来控制高级的操作。对于那些关键性的系统级设置，需要开锁后才能进行更改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/15.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 赋予禁用状态更多可能性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　禁用状态总是会令人联想到冷冰冰的系统规则，但如果善用禁用状态，信息传达将更有效。例如在Twitter发推时，提交过程中Tweet按钮变为禁用，同时在按钮左侧出现loading动画，通过两个UI元素的组合表达了提交中这一动作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/16.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　新版flickr的上传图片工具中，点击提交后，按钮立刻变为禁用状态，而有趣的文案“Hold on there，tiger”也给界面带来生动感。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-04/17.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　禁用状态是否始终可见，取决于它所属操作在界面中的功能属性。最重要的是保证核心功能交互体验流畅，用户不会形成理解上的困惑，然后再根据具体界面环境进行分析。如果需要展示禁用状态，我们必须让用户明白该操作变得可用的方法；如果需要隐藏禁用状态，在它出现时要让用户自然接受而不是“被吓了一跳”。更进一步，如果展示了禁用状态，那么就尽量避免样式上和可用状态的混淆，明确可点与不可点；在必要的时候给出解释和说明，不要让用户去猜测揣摩。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;原文地址:  &lt;a href=&quot;http://cdc.tencent.com/?p=7668&quot;&gt;http://cdc.tencent.com/?p=7668&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 04 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/2013/10/04/DisabledStateTwoOrThreeThings</link>
				<guid isPermaLink="true">http://ssy.me/%E8%A7%86%E8%A7%89%E8%AE%BE%E8%AE%A1/2013/10/04/DisabledStateTwoOrThreeThings</guid>
			</item>
		
			<item>
				<title>前端的困局与突围(from 玉伯)</title>
				<description>&lt;p&gt;&lt;img src=&quot;/blog-assets/2013-10-03/1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前端的价值究竟是什么？未来应该如何发展？&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;前端的价值&quot;&gt;前端的价值&lt;/h3&gt;

&lt;hr /&gt;
&lt;p&gt;　如果你刚入行，或者从事专职前端工作未满 3 年，请忽略上面这个问题，并且尽量不要再往下看了。&lt;/p&gt;

&lt;p&gt;　我知道你会忍不住往下看，那就看吧。负能量有时也是正能量。真实面对所做的事，如实面对自己的真心，这是迟早的。有过痛，才真正懂得乐。&lt;/p&gt;

&lt;p&gt;　特别注意，下面说的前端，都是阿里的前端，其他公司切勿对号入座，每个公司的情况都不同。每个公司，前端的定位也会有差异。&lt;/p&gt;

&lt;p&gt;　阿里的前端，目前主要分两种：一种在 UX / UED 部门，另一种在技术部门，所做的事大同小异，都是负责界面交互层的开发。上游是 PD、交互、视觉等，下游是后端开发人员、测试等。技能主要是 HTML、CSS、JavaScript，有些前端团队比如支付宝还直接负责 Velocity 等模板层的开发。这是阿里目前前端的现状。&lt;/p&gt;

&lt;p&gt;　前端是后端数据的第一消费者，也是最贴近用户的程序员。&lt;/p&gt;

&lt;p&gt;　一切看起来很美。&lt;/p&gt;

&lt;p&gt;　前端的价值在哪呢？很多人会回答：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;实现界面交互。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提升用户体验。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一点是前端的本职工作，也是前端岗位存在的原因。第二点也不多说，前端做得好，对用户体验是有益的。&lt;/p&gt;

&lt;p&gt;让人纠结的，是前端有价值，可是，这价值真的很重要吗？真的值得做为一个职业投入一辈子吗？&lt;/p&gt;

&lt;p&gt;做技术的，可能都会有类似纠结。但传统技术，纠结相对少点。比如搞数据库的，有一堆牛人榜样，搞网络、安全等等的，也是如此。这个现实的背后，是因为&lt;/p&gt;

&lt;p&gt;这批传统技术的背后，无论是数据库底层优化，还是网络优化、安全防范等等，做得好，对业务都能直接产生影响，比如大幅度降低硬件成本等等。 价值是直接的，可见的，不太会被质疑。&lt;/p&gt;

&lt;p&gt;然而前端的价值，没有人会直接否认，但看得明白的，都知道：&lt;/p&gt;

&lt;p&gt;淘宝的核心用户体验，并非是 UI 层面带来的，而是 C2C 的模式，是同等品质下商品的价格，还有支付宝的便捷等等。前端的确很重要，但真的，也就那么着。比如京东，很多交互细节做得其实不咋的，但京东靠着靠谱的物流、货到付款等方式提升了整体购物体验。对阿里来说，用户体验非常非常重要，但前端在用户体验层面能做的其实很少很少。&lt;/p&gt;

&lt;p&gt;一个事实：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;把国内大部分公司的 UX 部门解散掉，也不会太影响产品的体验。在国内，UX 主要还是起到美工的作用，虽然我不想承认。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前端依旧是美工，而且仅仅是实现工。&lt;/p&gt;

&lt;p&gt;在阿里，我们不得不承认一个事实：&lt;strong&gt;前端的确有价值，但放在全局来看，前端产生的价值并非核心价值。&lt;/strong&gt; 在阿里，虽然前端的工作已经不可或缺，但对大公司而言，不可或缺的岗位多了去呢，不可或缺不代表有核心价值，我就不说了。&lt;/p&gt;

&lt;h3 id=&quot;前端的未来发展&quot;&gt;前端的未来发展&lt;/h3&gt;

&lt;hr /&gt;
&lt;p&gt;前端，往后是技术，往前是体验。我的理解，前端的未来发展，有两个方向：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;前后端体系的融合，技术平台化。 范例是 Google、Facebook 等公司的技术体系，不细分前后端，都是 Web Developer，在整套技术平台上，Developer 都可以从后到前高效开发。技术平台本身由 Engineer 维护，有各个领域的高手，包括前端的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;前端技术带来的体验革新，成为某些产品的核心竞争力。 典型的比如 Path，国外有很多创新型项目，体验是核心竞争力之一。在这类产品中， 前端带来的用户体验很关键。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而，上面两个方向，在阿里的现状下，困难重重：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;技术平台化之路很难。 阿里现有的技术体系，前端只是薄薄的一层，要靠这薄薄的一层，来渗透甚至改革现有前后端开发模式，非常困难。支付宝算是走在前面，已经摸索了一年多，但越来越觉得，前端的绝大部分问题，其实都需要后端才能解决。去跨团队推动也可以，因为难，所以前行也挺有挑战挺有意义。可是，更悲催的事实是，技术平台化，前后端开发模式的融合，目前来看，并不是阿里的痛点，还没有到这一步，没这个强烈需求。需求不强烈，意味着缺了“天时”。很希望我的想法是错的。前后端的技术平台化之路，还有一个很现实的问题是，马云留下的隐患：平凡的人去做非凡的事。虽然现在有意不提这句话了。这句话很伤人，特别是技术人员，然而事实就是事实。即便技术平台能建成，在平台之上，阿里现有的开发人员，无论是前端还是后端，很多人可能还欠缺了不少能力。Facebook、Google 等玩起来，有个重要因素是精英文化。这话题不多说。现实的残酷，虽然也有方法是改变。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;体验创新之路也非常难。 在淘系可能相对好点，在支付宝，前几年首要的问题是安全、稳定，接下来几年之内，依旧是安全、稳定。创新受产品形态的影响非常大，没有一个好的产品，妄谈创新。可以有不少微创新，可以有很多小而美，但目前都触不到痛点，隔靴搔痒。真正承担阿里用户体验的，是 CDN 团队、是数据库团队、是 PD、是运营、是大安全…… 继续希望我是错的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上两个方向，虽然困难重重，但在一些新领域，却充满机会与希望：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;无线领域。 未来是属于无线的，这话说到心坎上。目前阿里的无线才起步，起步意味着百废待兴。无论是前后端的技术体系，还是产品的体验创新，在无线领域，前端的机遇与挑战都很多。并且其价值，有可能变成核心价值。这一点，希望我的判断是对的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Node.js 领域。严格来说是 JavaScript 程序员的新舞台。通过 Node，前端程序员可以摇身一变，变成传统程序员。数据库、网络、业务架构等等技术核心领域，都可以通过 JavaScript 来达成。Node 社区是迷人的。同样，希望我的判断是对的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的分类有点混乱，下面继续乱谈：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创业。 在很多产品中，前端虽然很难产生核心价值，但在有竞争的地方，附属价值经常会成为核心竞争力。比如出去创业，如何在大量同类产品中脱颖而出，前端界面层的实现非常关键。可是，无论是淘宝，还是支付宝等，目前都已经过了初期创业期。有时真希望，易趣如果还强大着该有多好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转行。 的确，没必要因为懂 JavaScript，就一辈子做前端。没必要限定自己的发展，可以做 2-3 年前端，然后再去做 2-3 年开发，还年轻的话，可以继续尝试各种岗位，说不定，10年后，就变 CTO 了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从人的一生来看，前端只是一段很小的旅途。它能带给你我们的已经不少，舍弃惯性，脱离舒适区，长远来看才能走得更远。放弃有时也是坚持，重要的是你心中的梦是什么。&lt;/p&gt;

&lt;h3 id=&quot;感悟与坚持&quot;&gt;感悟与坚持&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;纯技术上，前端目前的很多发展，只是在满足业务，并没有真正对业务带来“从无到有、促进变革”的变化。从公司的角度讲，并不需要那么多前端牛人。这是我那条说 HTML 高手是屠龙术的微博的含义。&lt;/p&gt;

&lt;p&gt;另一个角度上，前端技术这些年的变化，无论是 YUI 的发展、还是最近两三年兴起来的模块化开发理念、以及 Node.js 带来的前端工具变革、还有 Backbone 等类库背后的 MVX 的发展，这些都切实推动着前端往前发展，虽然很慢很慢，虽然短时间内很难直接影响业务价值，但我相信，这类工作的价值，也很大。&lt;/p&gt;

&lt;p&gt;一类是直接促进业务发展，一类是缓慢带动人员的成长。这两类工作，都非常有价值。一个着力于现在，一个发力于未来。&lt;/p&gt;

&lt;p&gt;原文转自:&lt;a href=&quot;https://github.com/lifesinger/lifesinger.github.com/issues/141&quot;&gt;https://github.com/lifesinger/lifesinger.github.com/issues/141&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 03 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/03/qianduan</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/03/qianduan</guid>
			</item>
		
			<item>
				<title>如何使用markdown</title>
				<description>&lt;p&gt;　　本文面向不了解 markdown 或刚准备上手的同学。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;它是什么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　首先，什么是 markdown？我们可以直接看一下 WIKI……不过 wiki很长，让人没有耐心读下去。那么，简单来说，markdown 其实是一种轻量级的标记语言；或者说，它规定了一些文本的书写格式，就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;写上你的标题
============

开始书写正文吧

当然也可以用 *列表* 的形式：
*   列表项目
*   还是列表项目
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　上面这一段东西就是 markdown 了——它看上去和普通的文本没什么两样，只不过文字“被一些
标记 格式化”了，所以看上去会感觉比较漂亮，书面化一点形容叫做 具备更高的可读性&lt;/p&gt;

&lt;p&gt;　　这一段 markdown 给我们的直观感受是我们能够清楚地识别出其中的“标题”、“段落”以及“列表”，
对，就和我们熟知的 html 一样，用来格式化内容&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为何使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　接下来的问题自然是，我们为什么要使用 markdown？&lt;/p&gt;

&lt;p&gt;　　我们可以把这个问题进一步拆分为三个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 markdown 而不是 html 的好处在哪&lt;/li&gt;
  &lt;li&gt;在哪些场景下使用？&lt;/li&gt;
  &lt;li&gt;这个东西的普及度如何？（这意味着它的前途）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　&lt;strong&gt;接下来一一回答:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;前文已说，markdown 和 html 都是一路的标记语言，用来格式化内容。而内容之所以要显得很格式化，是因为这样我们更容易阅读和理解。被渲染后的 html 是很可读的，但是 html 代码读起来就很糟糕，因为它夹杂着大量 &amp;lt;tag&amp;gt;；而 markdown 不管是写还是读，都很舒服。有一点需要注意的是，markdown 并不是为了取代 Html，因为根本取代不了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。最后一点，markdown 可以被编译为 html，比如使用在线的 Pandoc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我个人认为，我们在 txt 上写的文档或随手记之类的东西，就完全可以使用 markdown，简单且美观。另外，最重要的一点，我们可以在 支持把 markdown 编译为 html 的地方书写 markdown，好处是
显而易见的：书写简单、展现美观。典型的场景有：github 仓库的 README 描述文件、github 中的issue、评论框等。总而言之，把它用在要写文档的地方，妥妥的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们知道，这世界上还有很多类似于 markdown 的轻量级标记语言，比如形形色色的 wiki 语法。所以，我们凭什么使用 markdown 而不是 markup 或者 wikidown？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;答案很简单，因为它很流行。至少著名的程序员社区如 github 和 stackoverflow都提供了对它的大量支持&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　说了那么多，结论就是，学习并且使用 markdown，必须的！何况 markdown 学起来非常简单&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语法简要介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　接下来会非常简单地介绍一下语法，而详细的语法大全可以直接去 作者的官网 查看。
作者对语法的介绍富有条理且细致入微。&lt;/p&gt;

&lt;p&gt;　　语法介绍之后会着重说一下几个比较给力的特性，这个部分是重点&lt;/p&gt;

&lt;p&gt;部分语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用一个或多个空行分隔内容段来生成段落 &amp;lt;p&amp;gt;。

标题（h1~h6）格式为使用相应个数的“#”作前缀，比如以下代码表示 h3：
### this is a level-3 header ###
使用“&amp;gt;”作为段落前缀来标识引用文字段落。这其实是 email 中标记引用文字的标准方式：

&amp;gt;   引用的内容
&amp;gt;   这个记号直接借鉴的邮件标准


使用“*”“+”“-”来表示无序列表；使用数字加“.”表示有序列表。如：
1.  I am ordered list item 1...
2.  So I should be item 2!?
使用 4 个以上 空格或 1 个以上 的 tab 来标记代码段落，它们将被
&amp;lt;pre&amp;gt; 和 &amp;lt;code&amp;gt; 包裹，这意味着代码段内的字体会是 monospace
家族的，并且特殊符号不会被转义。

使用 [test](http://example.net &quot;optional title&quot;) 来标记普通链接。

使用 ![img](http://example.net/img.png &quot;optional title&quot;) 来标记图片。

引号内的 title 文字是可选的，链接也可以使用相对路径。

使用 * 或 _ 包裹文本产生 strong 效果：

_语气很重的文本_ 以及 **语气更重的文本**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;给力的特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　普通换行并不产生新的段落或&amp;lt;br&amp;gt;，但是产生空格。&lt;/p&gt;

&lt;p&gt;　　其实这个和 html 对 line-break 换行 的处理方式是一致的。为了使文本良好地展示在视野内，
我们会选择 手动地 将文字折行，但是并不意味着这两行在逻辑上不是一个段落。&lt;/p&gt;

&lt;p&gt;　　我们也可以插入真正的手动换行符&amp;lt;br&amp;gt;，如果要问&amp;lt;br&amp;gt; 在什么时候有用，下面是一个例子：&lt;/p&gt;

&lt;p&gt;我&lt;/p&gt;

&lt;p&gt;其实&lt;/p&gt;

&lt;p&gt;是一首&lt;/p&gt;

&lt;p&gt;诗……&lt;/p&gt;

&lt;p&gt;楼上 
这一段 
说得漂亮！
支持 setext-style 的 header 定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;定义 h1：

THIS IS THE MAIN TITLE
======================
定义 h2：

This is the subtitle
--------------------

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　更低级别的 header 就无法使用这种方式定义了。我们不用管 setext-style 是什么意思，只需要知道
这种标记方式更能凸显文章标题&lt;/p&gt;

&lt;p&gt;　　在 blockquote（“&amp;gt;”标记的段落） 之内可以嵌套使用其他标签，甚至可以再嵌套blockquote——&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;上古神书《商古》写道：
&amp;gt;   今有一鼎，镌以奇文：
&amp;gt;   &amp;gt;   吾乃鼎，非杯具也。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　支持引用式的链接格式。什么叫做“引用式”的链接呢，举例来说，
对于本文中的一段文字，相应的 mkd 代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先，什么是 markdown？我们可以直接看一下 [WIKI][1]……
另外，markdown 可以被编译为 html，比如使用在线的 [Pandoc][2]

    [1]:    http://en.wikipedia.org/wiki/Markdown   &quot;wiki_markdown&quot;

    [2]:    http://johnmacfarlane.net/pandoc/try    &quot;pandoc online&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　看上去就好像是“引用文献”的格式一样。好处非常易见：&lt;/p&gt;

&lt;p&gt;　正文文本中不会出现 url 链接这种读者不关心的信息，从而不影响读者的阅读&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结尾&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　以上便是对 markdown 的一个简要介绍了，需要了解进一步内容的，请移步&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown 项目主页&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wordpress.org/extend/plugins/markdown-for-wordpress-and-bbpress/&quot;&gt;WordPress 的 markdown 插件&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/&quot;&gt;中文版语法说明&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://johnmacfarlane.net/pandoc/&quot;&gt;强大的文本编译工具 Pandoc，支持 markdown 和 html 之间的互译&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Thu, 03 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/03/markdown</link>
				<guid isPermaLink="true">http://ssy.me/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/2013/10/03/markdown</guid>
			</item>
		
	</channel>
</rss>
